<?php
/**
 * EPUB Export class.
 *
 * @package Pressbooks
 * @author  Pressbooks <code@pressbooks.com>
 * @license GPLv3 (or any later version)
 */

namespace Pressbooks\Modules\Export\Epub;

use function Pressbooks\Sanitize\decode;
use function Pressbooks\Sanitize\sanitize_xml_attribute;
use function Pressbooks\Utility\debug_error_log;
use function Pressbooks\Utility\explode_remove_and;
use function Pressbooks\Utility\get_contributors_name_imploded;
use function Pressbooks\Utility\implode_add_and;
use function Pressbooks\Utility\str_ends_with;
use function Pressbooks\Utility\str_lreplace;
use function Pressbooks\Utility\str_starts_with;
use Pressbooks\Book;
use Pressbooks\Container;
use Pressbooks\Contributors;
use Pressbooks\HtmLawed;
use Pressbooks\HtmlParser;
use Pressbooks\Modules\Export\Export;
use Pressbooks\Modules\Export\ExportGenerator;
use Pressbooks\Modules\Export\ExportHelpers;
use Pressbooks\Sanitize;
use Pressbooks\Taxonomy;
use Pressbooks\Utility\PercentageYield;

class Epub extends ExportGenerator {
	use ExportHelpers;

	const VERSION = '3.2';

	/**
	 * @var array
	 */
	protected $fetchedImageCache = [];

	/**
	 * @var array
	 */
	protected $fetchedFontCache = [];

	/**
	 * Timeout in seconds.
	 * Used with wp_remote_get()
	 *
	 * @var int
	 */
	public $timeout = 90;

	/**
	 * @var string
	 */
	protected $stylesheet;

	/**
	 * @var bool
	 */
	protected $numbered = false;

	/**
	 * Temporary directory used to build EPUB, no trailing slash!
	 *
	 * @var string
	 */
	protected $tmpDir;

	/**
	 * Meta inf directory.
	 *
	 * @var string
	 */
	protected $metaInfDir;

	/**
	 * EPUB default directory.
	 *
	 * @var string
	 */
	protected $epubDir;

	/**
	 * Assets directory.
	 *
	 * @var string
	 */
	protected $assetsDir;

	/**
	 * Generated by createEPUB(), used by createToc(), createOPF(), and createNCX()
	 * Note: Only XHTML files go in the manifest array (images  are done automatically)
	 *
	 * @var array
	 */
	protected $manifest = [];

	/**
	 * We forcefully reorder some of the front-matter types to respect the Chicago Manual of Style.
	 * Keep track of where we are using this variable.
	 *
	 * @var int
	 */
	protected $frontMatterPos = 1;

	/**
	 * Last known front matter position. Used to insert the TOC in the correct place.
	 *
	 * @var int|bool
	 */
	protected $frontMatterLastPos = false;

	/**
	 * Sometimes the user will omit an introduction so we must inject the style in either the first
	 * part or the first chapter ourselves.
	 *
	 * @var bool
	 */
	protected $hasIntroduction = false;

	/**
	 * Should all header elements be wrapped in a container? Requires a theme based on Buckram.
	 *
	 * @see https://github.com/pressbooks/buckram/
	 *
	 * @var bool
	 */
	protected $wrapHeaderElements = false;

	/**
	 * Used to set cover-image in OPF for kindlegen compatibility.
	 *
	 * @var string
	 */
	protected $coverImage;

	/**
	 * Fullpath to book CSS file.
	 *
	 * @var string
	 */
	protected $exportStylePath;

	/**
	 * CSS overrides
	 *
	 * @var string
	 */
	protected $cssOverrides;

	/**
	 * Used by HtmLawed with $GLOBALS['hl_Ids']
	 *
	 * @var array
	 */
	protected $fixme;

	/**
	 * @var bool
	 */
	protected $compressImages = false;

	/**
	 * @var string
	 */
	protected $generatorPrefix;

	/**
	 * @var string
	 */
	protected $filext = 'xhtml';

	/**
	 * $var string
	 */
	protected $dir = __DIR__;

	/**
	 * $var string
	 */
	protected $suffix = '.epub';

	/**
	 * Main language of document, two letter code
	 *
	 * @var string
	 */
	protected $lang = 'en';

	/**
	 * Regular expression for supported images (used in #($supportedImageExtensions)#i')
	 *
	 * @var string
	 */
	protected $supportedImageExtensions = '\.jpe?g|\.gif|\.png';

	/**
	 * Regular expression for supported fonts  (used in #($supportedFontExtensions)#i')
	 *
	 * @var string
	 */
	protected $supportedFontExtensions = '\.ttf|\.otf';

	/**
	 * Extra CSS (to be used by child classes if necessary)
	 *
	 * @var string
	 */
	protected $extraCss = null;

	/**
	 * @var Taxonomy
	 */
	protected $taxonomy;

	/**
	 * @var Contributors
	 */
	protected $contributors;

	/**
	 * @var array [original slug -> sanitized slug]
	 */
	protected $sanitizedSlugs = [];

	/**
	 * @var bool
	 */
	protected $displayAboutTheAuthors;

	/**
	 * MathML Tags
	 *
	 * @var array
	 */
	protected $MathMLTags = [
		'math',
		'maction',
		'maligngroup',
		'malignmark',
		'menclose',
		'merror',
		'mfenced',
		'mfrac',
		'mglyph',
		'mi',
		'mlabeledtr',
		'mlongdiv',
		'mmultiscripts',
		'mn',
		'mo',
		'mover',
		'mpadded',
		'mphantom',
		'mroot',
		'mrow',
		'ms',
		'mscarries',
		'mscarry',
		'msgroup',
		'msline',
		'mspace',
		'msqrt',
		'msrow',
		'mstack',
		'mstyle',
		'msub',
		'msup',
		'msubsup',
		'mtable',
		'mtd',
		'mtext',
		'mtr',
		'munder',
		'munderover',
		'semantics',
		'annotation',
		'annotation-xml',
	];

	/**
	 * JavaScript Events
	 *
	 * @var array
	 */
	protected $javaScriptEvents = [
		'onabort',
		'onblur',
		'oncanplay',
		'oncanplaythrough',
		'onchange',
		'onclick',
		'oncontextmenu',
		'ondblclick',
		'ondrag',
		'ondragend',
		'ondragenter',
		'ondragleave',
		'ondragover',
		'ondragstart',
		'ondrop',
		'ondurationchange',
		'onemptied',
		'onended',
		'onerror',
		'onfocus',
		'oninput',
		'oninvalid',
		'onkeydown',
		'onkeypress',
		'onkeyup',
		'onload',
		'onloadeddata',
		'onloadedmetadata',
		'onloadstart',
		'onmousedown',
		'onmousemove',
		'onmouseout',
		'onmouseover',
		'onmouseup',
		'onmousewheel',
		'onpause',
		'onplay',
		'onplaying',
		'onprogress',
		'onratechange',
		'onreadystatechange',
		'onreset',
		'onscroll',
		'onseeked',
		'onseeking',
		'onselect',
		'onshow',
		'onstalled',
		'onsubmit',
		'onsuspend',
		'ontimeupdate',
		'onvolumechange',
		'onwaiting',
	];

	/**
	 * @var Blade
	 */
	protected $blade;

	/**
	 * @param array $args
	 */
	public function __construct( array $args ) {
		// Some defaults
		$this->taxonomy = Taxonomy::init();
		$this->contributors = Contributors::init();
		$this->blade = Container::get( 'Blade' );

		if ( ! class_exists( '\PclZip' ) ) {
			require_once( ABSPATH . 'wp-admin/includes/class-pclzip.php' );
		}

		if ( ! defined( 'PB_EPUBCHECK_COMMAND' ) ) {
			define( 'PB_EPUBCHECK_COMMAND', '/usr/bin/java -jar /opt/epubcheck/epubcheck.jar' );
		}

		$this->tmpDir = $this->createTmpDir();
		$this->metaInfDir = $this->tmpDir . '/META-INF';
		$this->epubDir = $this->tmpDir . '/EPUB';
		$this->assetsDir = $this->epubDir . '/assets';

		$this->exportStylePath = $this->getExportStylePath( 'epub' );

		if ( Container::get( 'Styles' )->hasBuckram( '0.3.0' ) ) {
			$this->wrapHeaderElements = true;
		}

		$this->themeOptionsOverrides();

		// HtmLawed: id values not allowed in input
		foreach ( $this->reservedIds as $val ) {
			$this->fixme[ $val ] = 1;
		}

		$this->generatorPrefix = sprintf( __( 'EPUB %s: ', 'pressbooks' ), self::VERSION );
	}

	/**
	 * Delete temporary directory when done.
	 */
	public function __destruct() {
		$this->deleteTmpDir();
	}

	/**
	 * Check for existence of properties attributes
	 *
	 * @param string $html_file
	 *
	 * @return array
	 * @throws \Exception
	 */
	protected function getProperties( string $html_file ): array {
		$html = \Pressbooks\Utility\get_contents( $html_file );
		$properties = [];

		if ( empty( $html ) ) {
			throw new \Exception( 'File contents empty for getProperties' );
		}

		if ( $this->isMathML( $html ) ) {
			$properties['mathml'] = 1;
		}

		if ( $this->isScripted( $html ) ) {
			$properties['scripted'] = 1;
		}

		// TODO: Check for remote resources

		return $properties;
	}

	/**
	 * Check for existence of scripting MathML elements
	 *
	 * @param string $html
	 *
	 * @return bool
	 */
	protected function isMathML( string $html ): bool {
		foreach ( $this->MathMLTags as $tag ) {
			if ( false !== stripos( $html, "<$tag>" ) ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Check for existence of scripting elements
	 *
	 * @param string $html
	 *
	 * @return bool
	 */
	protected function isScripted( string $html ): bool {
		if ( preg_match( '/<script[^>]*>.*?<\/script>/is', $html ) ) {
			return true;
		}

		try {
			$html5 = new HtmlParser( true );
			$doc = $html5->loadHTML( $html );
			foreach ( $doc->getElementsByTagname( '*' ) as $element ) {
				foreach ( iterator_to_array( $element->attributes ) as $name => $attribute ) {
					if ( in_array( $name, $this->javaScriptEvents, true ) ) {
						return true;
					}
				}
			}
		} catch ( \Exception $e ) {
			debug_error_log( $e );
		}

		return false;
	}

	/**
	 * Create $this->outputPath
	 *
	 * @return bool
	 */
	public function convert(): bool {
		$this->extraCss = $this->dir . '/templates/css/css3.css';

		try {
			foreach ( $this->convertGenerator() as $percentage => $info ) {
				// Do nothing, this is a compatibility wrapper that makes the generator work like a regular function
			}
		} catch ( \Exception $e ) {
			return false;
		}
		return true;
	}

	/**
	 * Yields an estimated percentage slice of: 1 to 80
	 *
	 * @return \Generator
	 * @throws \Exception
	 */
	public function convertGenerator(): \Generator {
		yield 1 => $this->generatorPrefix . __( 'Initializing', 'pressbooks' );

		// Sanity check
		if ( empty( $this->tmpDir ) || ! is_dir( $this->tmpDir ) ) {
			$this->logError( '$this->tmpDir must be set before calling convert().' );
			throw new \Exception();
		}

		if ( empty( $this->exportStylePath ) || ! is_file( $this->exportStylePath ) ) {
			$this->logError( '$this->exportStylePath must be set before calling convert().' );
			throw new \Exception();
		}

		// Convert
		yield 2 => $this->generatorPrefix . __( 'Preparing book contents', 'pressbooks' );
		$this->displayAboutTheAuthors = ! empty( get_option( 'pressbooks_theme_options_global', [] )['about_the_author'] );
		$metadata = Book::getBookInformation();
		$book_contents = $this->preProcessBookContents( Book::getBookContents() );

		// Set two letter language code
		if ( isset( $metadata['pb_language'] ) ) {
			[ $this->lang ] = explode( '-', $metadata['pb_language'] );
		}

		try {
			yield 5 => $this->generatorPrefix . __( 'Creating container', 'pressbooks' );
			$this->createContainer();
			yield from $this->createEPUBGenerator( $book_contents, $metadata );
			$this->createOPF( $book_contents, $metadata );
			$this->createNCX( $book_contents, $metadata );
		} catch ( \Exception $e ) {
			$this->logError( $e->getMessage() );
			throw new \Exception();
		}

		yield 75 => $this->generatorPrefix . __( 'Saving file to exports folder', 'pressbooks' );
		$filename = $this->timestampedFileName( $this->suffix );

		if ( ! $this->zipEpub( $filename ) ) {
			throw new \Exception();
		}

		$this->outputPath = $filename;
		yield 80 => $this->generatorPrefix . __( 'Export successful', 'pressbooks' );
	}

	/**
	 * @param array $book_contents
	 *
	 * @return array
	 */
	protected function preProcessBookContents( array $book_contents ): array {
		// We need to change global $id for shortcodes, the_content, ...
		global $id;
		$old_id = $id;

		// Do root level structures first.
		foreach ( $book_contents as $type => $struct ) {

			if ( 0 === strpos( $type, '__' ) ) {
				continue; // Skip __magic keys
			}

			foreach ( $struct as $i => $val ) {
				if ( isset( $val['post_content'] ) ) {
					$id = $val['ID'];
					$book_contents[ $type ][ $i ]['post_content'] = $this->preProcessPostContent( $val['post_content'], $type, $val['ID'] );
				}
				if ( isset( $val['post_title'] ) ) {
					$book_contents[ $type ][ $i ]['post_title'] = sanitize_xml_attribute( $val['post_title'] );
				}
				if ( isset( $val['post_name'] ) ) {
					$book_contents[ $type ][ $i ]['post_name'] = $this->preProcessPostName( $val['post_name'] );
					$this->sanitizedSlugs[ $val['post_name'] ] = $book_contents[ $type ][ $i ]['post_name'];
				}

				if ( 'part' === $type ) {
					// Do chapters, which are embedded in part structure
					foreach ( $book_contents[ $type ][ $i ]['chapters'] as $j => $val2 ) {
						if ( isset( $val2['post_content'] ) ) {
							$id = $val2['ID'];
							$book_contents[ $type ][ $i ]['chapters'][ $j ]['post_content'] = $this->preProcessPostContent( $val2['post_content'], 'chapter', $val2['ID'] );
						}
						if ( isset( $val2['post_title'] ) ) {
							$book_contents[ $type ][ $i ]['chapters'][ $j ]['post_title'] = sanitize_xml_attribute( $val2['post_title'] );
						}
						if ( isset( $val2['post_name'] ) ) {
							$book_contents[ $type ][ $i ]['chapters'][ $j ]['post_name'] = $this->preProcessPostName( $val2['post_name'] );
							$this->sanitizedSlugs[ $val2['post_name'] ] = $book_contents[ $type ][ $i ]['chapters'][ $j ]['post_name'];
						}
					}
				}
			}
		}

		$id = $old_id;
		return $book_contents;
	}

	/**
	 * @param string $content
	 * @param string $type
	 * @param int $post_id
	 *
	 * @return string
	 */
	protected function preProcessPostContent( string $content, string $type = '', int $post_id = 0 ): string {
		if (
			$this->displayAboutTheAuthors &&
			in_array( $type, [ 'chapter', 'front-matter', 'back-matter' ], true ) &&
			$post_id > 0
		) {
			$content .= \Pressbooks\Modules\Export\get_contributors_section( $post_id );
		}
		$content = apply_filters( 'the_export_content', $content );
		$content = str_ireplace( [ '<b></b>', '<i></i>', '<strong></strong>', '<em></em>' ], '', $content );
		return $this->tidy( $content );
	}

	/*
	 * @return bool
	 */
	public function validate(): bool {
		try {
			foreach ( $this->validateGenerator() as $percentage => $info ) {
				// Do nothing, this is a compatibility wrapper that makes the generator work like a regular function
			}
		} catch ( \Exception $e ) {
			return false;
		}
		return true;
	}

	/**
	 * Yields an estimated percentage slice of: 80 to 100
	 *
	 * @return \Generator
	 * @throws \Exception
	 */
	public function validateGenerator() : \Generator {
		yield 80 => $this->generatorPrefix . __( 'Validating file', 'pressbooks' );

		// Epubcheck command, (quiet flag requires version 3.0.1+)
		$command = PB_EPUBCHECK_COMMAND . ' -q ' . escapeshellcmd( $this->outputPath ) . ' 2>&1';

		// Execute command
		$output = [];
		$return_var = 0;
		exec( $command, $output, $return_var );

		foreach ( $output as $k => $v ) {
			if (
				str_contains( $v, 'Picked up _JAVA_OPTIONS:' ) ||
				str_contains( $v, 'non-standard font type application/x-font-ttf' ) ||
				str_contains( $v, 'non-standard font type application/font-sfnt' )
			) {
				unset( $output[ $k ] );
			}
		}

		// Is this a valid Epub?
		if ( ! empty( $output ) ) {
			$this->logError( implode( "\n", $output ) );
			throw new \Exception();
		}

		yield 90 => $this->generatorPrefix . __( 'Validation successful', 'pressbooks' );
		yield 100 => $this->generatorPrefix . __( 'Finishing up', 'pressbooks' );
	}

	/**
	 * Override mimeType, get rid of '; charset=binary'
	 *
	 * @param string $file
	 *
	 * @return string
	 */
	public function mediaType( string $file ): string {

		$mime = static::mimeType( $file );
		$mime = explode( ';', $mime );

		return $mime[0] === 'font/sfnt' ? 'application/font-sfnt' : trim( $mime[0] );
	}

	/**
	 * Override based on Theme Options
	 *
	 * @return void
	 */
	protected function themeOptionsOverrides(): void {

		// --------------------------------------------------------------------
		// CSS

		$css = '';
		$this->cssOverrides = apply_filters( 'pb_epub_css_override', $css ) . "\n";

		// --------------------------------------------------------------------
		// Hacks

		$hacks = [];
		$hacks = apply_filters( 'pb_epub_hacks', $hacks );

		// Display chapter numbers?
		if ( isset( $hacks['chapter_numbers'] ) && $hacks['chapter_numbers'] ) {
			$this->numbered = true;
		} else {
			$this->numbered = false;
		}

		if ( isset( $hacks['ebook_compress_images'] ) && $hacks['ebook_compress_images'] ) {
			$this->compressImages = true;
		}

	}

	/**
	 * Tidy HTML
	 *
	 * @param string $html
	 *
	 * @return string
	 */
	protected function tidy( string $html ): string {
		// Venn diagram join between XTHML + HTML5 Deprecated Attributes
		//
		// Our $spec is artisanally hand crafted based on squinting very hard while reading the following docs:
		//
		//  + 2.3 - Extra HTML specifications using the $spec parameter
		//  + 3.4.6 -  Transformation of deprecated attributes
		//  + 3.3.2  - Tag-transformation for better compliance with standards
		//  + HTML5 - Deprecated Tags & Attributes
		//
		// That is we do not remove deprecated attributes that are already transformed by htmLawed
		//
		// More info:
		//  + http://www.bioinformatics.org/phplabware/internal_utilities/htmLawed/beta/htmLawed_README.htm
		//  + http://www.tutorialspoint.com/html5/html5_deprecated_tags.htm

		$config = [
			'valid_xhtml' => 1,
			'no_deprecated_attr' => 2,
			'unique_ids' => 'fixme-',
			'hook' => '\Pressbooks\Sanitize\html5_to_epub3',
			'tidy' => -1,
			'make_tag_strict' => 2,
			'comment' => 1,
		];

		$spec = '';
		$spec .= 'a=,-charset,-coords,-rev,-shape;';
		$spec .= 'area=-nohref;';
		$spec .= 'col=-align,-char,-charoff,-valign,-width;';
		$spec .= 'colgroup=-align,-char,-charoff,-valign,-width;';
		$spec .= 'div=-align;';
		$spec .= 'iframe=-align,-frameborder,-longdesc,-marginheight,-marginwidth,-scrolling;';
		$spec .= 'img=-longdesc,-srcset;';
		$spec .= 'link=-charset,-rev,-target;';
		$spec .= 'menu=-compact;';
		$spec .= 'object=-archive,-classid,-codebase,-codetype,-declare,-standby;';
		$spec .= 'param=-type,-valuetype;';
		$spec .= 't=-abbr,-axis;';
		$spec .= 'table=-border,-cellpadding,-frame,-rules;';
		$spec .= 'tbody=-align,-char,-charoff,-valign;';
		$spec .= 'td=-axis,-abbr,-align,-char,-charoff,-scope,-valign;';
		$spec .= 'tfoot=-align,-char,-charoff,-valign;';
		$spec .= 'th=-align,-char,-charoff,-valign;';
		$spec .= 'thead=-align,-char,-charoff,-valign;';
		$spec .= 'tr=-align,-char,-charoff,-valign;';
		$spec .= 'ul=-type;';

		// Reset on each htmLawed invocation
		unset( $GLOBALS['hl_Ids'] );
		if ( ! empty( $this->fixme ) ) {
			$GLOBALS['hl_Ids'] = $this->fixme;
		}

		return HtmLawed::filter( $html, $config, $spec );
	}

	/**
	 * Fetch a url with wp_remote_get(), save it to $fullpath with a unique name.
	 * Will return an empty string if something went wrong.
	 *
	 * @param string $url
	 * @param string $fullpath
	 *
	 * @return string|array
	 */
	protected function fetchAndSaveUniqueMedia( string $url, string $fullpath ) {
		if ( isset( $this->fetchedMediaCache[ $url ] ) ) {
			return $this->fetchedMediaCache[ $url ];
		}

		$response = wp_remote_get(
			$url, [
				'timeout' => $this->timeout,
			]
		);

		// WordPress error?
		if ( is_wp_error( $response ) ) {
			try {
				// protocol relative urls handed to wp_remote_get will fail
				// try adding a protocol
				$protocol_relative = wp_parse_url( $url );
				if ( ! isset( $protocol_relative['scheme'] ) ) {
					if ( true === is_ssl() ) {
						$url = 'https:' . $url;
					} else {
						$url = 'http:' . $url;
					}
				}
				$response = wp_remote_get(
					$url, [
						'timeout' => $this->timeout,
					]
				);
				if ( is_wp_error( $response ) ) {
					throw new \Exception( 'Bad URL: ' . $url );
				}
			} catch ( \Exception $exc ) {
				$this->fetchedImageCache[ $url ] = '';
				debug_error_log( '\PressBooks\Export\Epub3\fetchAndSaveUniqueMedia wp_error on wp_remote_get() - ' . $response->get_error_message() . ' - ' . $exc->getMessage() );
				return '';
			}
		}

		// Basename without query string
		$filename = explode( '?', basename( $url ) );
		$filename = array_shift( $filename );
		$filename = explode( '#', $filename )[0]; // Remove trailing anchors
		$filename = sanitize_file_name( urldecode( $filename ) );
		$filename = Sanitize\force_ascii( $filename );

		// A book with a lot of media can trigger "Fatal Error Too many open files" because tmpfiles are not closed until PHP exits
		// Use a $resource_key so we can close the tmpfile ourselves
		$resource_key = uniqid( 'tmpfile-epub-', true );
		$tmp_file = \Pressbooks\Utility\create_tmp_file( $resource_key );
		\Pressbooks\Utility\put_contents( $tmp_file, wp_remote_retrieve_body( $response ) );

		if ( ! \Pressbooks\Media\is_valid_media( $tmp_file, $filename ) ) {
			$this->fetchedMediaCache[ $url ] = '';
			fclose( $GLOBALS[ $resource_key ] ); // @codingStandardsIgnoreLine
			return ''; // Not a valid media type
		}

		// Check for duplicates, save accordingly
		if ( ! file_exists( "$fullpath/$filename" ) ) {
			copy( $tmp_file, "$fullpath/$filename" );
		} elseif ( md5( \Pressbooks\Utility\get_contents( $tmp_file ) ) !== md5( \Pressbooks\Utility\get_contents( "$fullpath/$filename" ) ) ) {
			$filename = wp_unique_filename( $fullpath, $filename );
			copy( $tmp_file, "$fullpath/$filename" );
		}
		fclose( $GLOBALS[ $resource_key ] ); // @codingStandardsIgnoreLine

		$this->fetchedMediaCache[ $url ] = $filename;

		return $filename;
	}

	/**
	 * Clean up content processed by HTML5 Parser, change it back into XHTML
	 *
	 * @param string $html
	 *
	 * @return string
	 */
	protected function html5ToXhtml( string $html ): string {
		$config = [
			'valid_xhtml' => 1,
			'unique_ids' => 0,
		];

		return HtmLawed::filter( $html, $config );
	}

	/**
	 * Delete temporary directory
	 *
	 * @return void
	 */
	protected function deleteTmpDir(): void {
		// Cleanup temporary directory, if any
		if ( ! empty( $this->tmpDir ) ) {
			\Pressbooks\Utility\rmrdir( $this->tmpDir );
		}
	}

	/**
	 * Zip the contents of an EPUB following the conventions outlined in Open Publication Structure 2.0.1
	 *
	 * @param string $filename
	 *
	 * @return bool
	 */
	protected function zipEpub( string $filename ): bool {
		$zip = new \PclZip( $filename );

		// Open Publication Structure 2.0.1
		// mimetype must be uncompressed, unencrypted, and the first file in the ZIP archive
		$list = $zip->create( $this->tmpDir . '/mimetype', PCLZIP_OPT_NO_COMPRESSION, PCLZIP_OPT_REMOVE_ALL_PATH );
		if ( 0 === absint( $list ) ) {
			return false;
		}

		$files = [];
		foreach ( new \RecursiveIteratorIterator( new \RecursiveDirectoryIterator( $this->tmpDir ) ) as $file ) {
			if ( ! $file->isFile() ) {
				continue;
			}
			if ( 'mimetype' === $file->getFilename() ) {
				continue;
			}
			$files[] = $file->getPathname();
		}

		$list = $zip->add( $files, '', $this->tmpDir );

		if ( 0 === absint( $list ) ) {
			return false;
		}

		return true;
	}

	/**
	 * Create Open Publication Structure 2.0.1 container.
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function createContainer(): void {
		$this->createEpubFile( 'mimetype', utf8_decode( 'application/epub+zip' ), [ 'directory' => $this->tmpDir ] );

		mkdir( $this->metaInfDir );
		mkdir( $this->epubDir );
		mkdir( $this->assetsDir );

		$this->createEpubFile( 'container.xml', [], [
			'directory' => $this->metaInfDir,
			'template' => 'container',
		] );

		$this->createEpubFile( 'com.apple.ibooks.display-options.xml', [], [
			'directory' => $this->metaInfDir,
			'template' => 'ibooks',
		] );
	}

	/**
	 * Yields an estimated percentage slice of: 10 to 75
	 * Create EPUB/* files.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return \Generator
	 * @throws \Exception
	 */
	protected function createEPUBGenerator( array $book_contents, array $metadata ) : \Generator {
		// First, setup and affect $this->stylesheet
		yield 10 => $this->generatorPrefix . __( 'Compiling styles', 'pressbooks' );
		$this->createStylesheet();

		// Reset manifest
		$this->manifest = [];

		/* Note: order affects $this->manifest */

		// Cover
		yield 15 => $this->generatorPrefix . __( 'Creating cover', 'pressbooks' );
		$this->renderCover( $metadata );

		// Before Title Page
		$this->renderBeforeTitle( $book_contents, $metadata );

		// Title
		yield 20 => $this->generatorPrefix . __( 'Creating title page', 'pressbooks' );
		$this->renderTitle( $book_contents, $metadata );

		// Copyright
		yield 20 => $this->generatorPrefix . __( 'Creating copyright page', 'pressbooks' );
		$this->renderCopyright( $metadata );

		// Dedication and Epigraph (In that order!)
		yield 25 => $this->generatorPrefix . __( 'Exporting dedication and epigraph', 'pressbooks' );
		$this->renderDedicationAndEpigraph( $book_contents, $metadata );

		// Front-matter
		yield 30 => $this->generatorPrefix . __( 'Exporting front matter', 'pressbooks' );
		yield from $this->renderFrontMatterGenerator( $book_contents, $metadata );

		// Promo
		$this->renderPromo( $book_contents, $metadata );

		// Parts, Chapters
		yield 40 => $this->generatorPrefix . __( 'Exporting parts and chapters', 'pressbooks' );
		yield from $this->renderPartsAndChaptersGenerator( $book_contents, $metadata );

		// Back-matter
		yield 50 => $this->generatorPrefix . __( 'Exporting back matter', 'pressbooks' );
		yield from $this->renderBackMatterGenerator( $book_contents, $metadata );

		// Table of contents
		// IMPORTANT: Do this last! Uses $this->manifest to generate itself
		yield 70 => $this->generatorPrefix . __( 'Creating table of contents', 'pressbooks' );
		$this->renderToc( $metadata );
	}

	/**
	 * Create stylesheet. Change $this->stylesheet to a filename used by subsequent methods.
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function createStylesheet(): void {
		$this->stylesheet = strtolower( sanitize_file_name( wp_get_theme() . '.css' ) );

		$this->createEpubFile( $this->stylesheet, \Pressbooks\Utility\get_contents( $this->exportStylePath ) );

		$this->scrapeKneadAndSaveCss( $this->exportStylePath, $this->epubDir . '/' . $this->stylesheet );
	}

	/**
	 * Parse CSS, copy assets, rewrite copy.
	 *
	 * @param string $path_to_original_stylesheet *
	 * @param string $path_to_copy_of_stylesheet
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function scrapeKneadAndSaveCss( string $path_to_original_stylesheet, string $path_to_copy_of_stylesheet ): void {
		$styles = Container::get( 'Styles' );

		$scss = \Pressbooks\Utility\get_contents( $path_to_copy_of_stylesheet );

		if ( $this->extraCss ) {
			$scss .= "\n" . \Pressbooks\Utility\get_contents( $this->extraCss );
		}

		$custom_styles = $styles->getEpubPost();
		if ( $custom_styles && ! empty( $custom_styles->post_content ) ) {
			// append the user's custom styles to the theme stylesheet prior to compilation
			$scss .= "\n" . $custom_styles->post_content;
		}

		$css = $styles->customize( 'epub', $scss, $this->cssOverrides );

		$scss_dir = pathinfo( $path_to_original_stylesheet, PATHINFO_DIRNAME );
		$css = $this->normalizeCssUrls( $css, $scss_dir, $this->assetsDir );

		$css = $this->normalizeExternalFontsUrls( $css, $this->assetsDir );

		// Overwrite the new file with new info
		$this->createEpubFile( $this->stylesheet, $css );

		if ( WP_DEBUG ) {
			Container::get( 'Sass' )->debug( $css, $scss, 'epub' );
		}

	}

	/**
	 * Download external fonts to include them and rewrite the CSS.
	 *
	 * @param string $css
	 * @param string $path_to_epub_assets
	 * @return string
	 */
	public function normalizeExternalFontsUrls( string $css, string $path_to_epub_assets ): string {
		foreach ( preg_split( "/((\r?\n)|(\r\n?) )/", $css ) as $line ) {
			if ( str_contains( $line, '@import "https://' ) ) {
				preg_match_all( '#\bhttps?://[^,\s()<>]+(?:\([\w\d]+\)|([^,[:punct:]\s]|/))#', $line, $match );
				$new_filename = $this->fetchAndSaveUniqueFont( $match[0][0], $path_to_epub_assets );

				$string_replacement = $new_filename ? '@import url(assets/' . $new_filename . ');' : '';
				$css = str_replace( $line, $string_replacement, $css );
			}
		}

		return $css;
	}

	/**
	 * Search for all possible permutations of CSS url syntax -- url("*"), url('*'), and url(*) -- and update URLs as needed.
	 *
	 * @param string $css The EPUB's (S)CSS content.
	 * @param string $scss_dir The directory which contains the theme's SCSS files. No trailing slash.
	 * @param string $path_to_epub_assets The EPUB's assets directory. No trailing slash,
	 *
	 * @return string
	 */
	protected function normalizeCssUrls( string $css, string $scss_dir, string $path_to_epub_assets ): string {
		$url_regex = '/url\(([\s])?([\"|\'])?(.*?)([\"|\'])?([\s])?\)/i';

		$css = preg_replace_callback(
			$url_regex, function ( $matches ) use ( $scss_dir, $path_to_epub_assets ) {

				$buckram_dir = get_theme_root( 'pressbooks-book' ) . '/pressbooks-book/packages/buckram/assets';
				$typography_dir = get_theme_root( 'pressbooks-book' ) . '/pressbooks-book/assets/book/typography';

				$url = $matches[3];
				$filename = sanitize_file_name( basename( $url ) );

				// Look for images in Buckram
				if ( preg_match( '#^pressbooks-book/assets/book/images/[a-zA-Z0-9_-]+(' . $this->supportedImageExtensions . ')$#i', $url ) ) {
					$url = str_replace( 'pressbooks-book/assets/book/', '', $url );
					$my_image = realpath( "$buckram_dir/$url" );
					if ( $my_image ) {
						copy( $my_image, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^images/[a-zA-Z0-9_-]+(' . $this->supportedImageExtensions . ')$#i', $url ) ) {
					$my_image = realpath( "$buckram_dir/$url" );
					if ( $my_image ) {
						copy( $my_image, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					} else {
						// This is not a Buckram theme, maybe.
						$my_legacy_image = realpath( "$scss_dir/$url" );
						if ( $my_legacy_image ) {
							copy( $my_legacy_image, "$path_to_epub_assets/$filename" );
							return "url(assets/$filename)";
						}
					}
				} elseif ( preg_match( '#^images/#', $url ) && substr_count( $url, '/' ) === 1 ) {

					// Look for "^images/"
					// Count 1 slash so that we don't touch stuff like "^images/out/of/bounds/"	or "^images/../../denied/"

					$my_image = realpath( "$scss_dir/$url" );
					if ( $my_image ) {
						copy( $my_image, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^../../images/epub/#', $url ) && substr_count( $url, '/' ) === 4 ) {

					// Look for "^../../images/epub/"
					// Count 4 slashes so that we explicitly select the path to the new assets directory

					$my_image = realpath( "$scss_dir/$url" );
					if ( $my_image ) {
						copy( $my_image, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^https?://#i', $url ) && preg_match( '/(' . $this->supportedImageExtensions . ')$/i', $url ) ) {

					// Look for images via http(s), pull them in locally

					$new_filename = $this->fetchAndSaveUniqueImage( $url, $path_to_epub_assets );
					if ( $new_filename ) {
						return "url(assets/$new_filename)";
					}
				} elseif ( preg_match( '#^themes-book/pressbooks-book/fonts/[a-zA-Z0-9_-]+(' . $this->supportedFontExtensions . ')$#i', $url ) ) {

					// Update themes-book/pressbooks-book/fonts/*.ttf (or .otf) path to new location, copy into our Epub
					$url = str_replace( 'themes-book/pressbooks-book/', trailingslashit( $typography_dir ), $url );
					$my_font = realpath( $url );

					if ( $my_font ) {
						copy( $my_font, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^fonts/[a-zA-Z0-9_-]+(' . $this->supportedFontExtensions . ')$#i', $url ) ) {

					// Look for wp-content/themes/pressbooks-book/assets/typography/fonts/*.ttf (or .otf), copy into our Epub

					$my_font = realpath( "$typography_dir/$url" );
					if ( $my_font ) {
						copy( $my_font, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^uploads/assets/fonts/[a-zA-Z0-9_-]+(' . $this->supportedFontExtensions . ')$#i', $url ) ) {

					// Look for wp-content/uploads/assets/typography/fonts/*.ttf (or .otf), copy into our Epub

					$my_font = realpath( WP_CONTENT_DIR . '/' . $url );
					if ( $my_font ) {
						copy( $my_font, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^https?://#i', $url ) && preg_match( '/(' . $this->supportedFontExtensions . ')$/i', $url ) ) {

					// Look for fonts via http(s), pull them in locally

					$new_filename = $this->fetchAndSaveUniqueFont( $url, $path_to_epub_assets );
					if ( $new_filename ) {
						return "url(assets/$new_filename)";
					}
				}

				return $matches[0]; // No change

			}, $css
		);

		return $css;
	}

	/**
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderCover( array $metadata ): void {
		if ( ! empty( $metadata['pb_cover_image'] ) && ! \Pressbooks\Image\is_default_cover( $metadata['pb_cover_image'] ) ) {
			$source_path = \Pressbooks\Utility\get_media_path( $metadata['pb_cover_image'] );
		} else {
			$source_path = \Pressbooks\Image\default_cover_path();
		}

		$dest_image = sanitize_file_name( basename( $source_path ) );
		$dest_image = Sanitize\force_ascii( $dest_image );
		$dest_path = $this->assetsDir . '/' . $dest_image;

		$img = wp_get_image_editor( $source_path );

		if ( ! is_wp_error( $img ) ) {
			$img->resize( 1563, 2500, false ); // in case image wasn't resized upon upload
			$img->save( $dest_path );
			$this->coverImage = $dest_image;
		}

		// HTML
		$html = $this->blade->render(
			'export/cover', [
				'src' => $this->coverImage,
				'alt' => get_bloginfo( 'name' ),
			]
		);

		// Create file, insert into manifest
		$vars = [
			'post_title' => __( 'Cover', 'pressbooks' ),
			'stylesheet' => $this->stylesheet,
			'post_content' => $html,
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$file_id = 'front-cover';
		$filename = $this->generateFilename( $file_id );

		$this->createEpubFile( $filename, $vars );
		$this->updateManifest( $file_id, [
			'ID' => -1,
			'post_title' => $vars['post_title'],
			'filename' => $filename,
		] );
	}

	/**
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderBeforeTitle( array $book_contents, array $metadata ): void {
		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$index = $this->frontMatterPos;
		foreach ( [ 'before-title' ] as $compare ) {
			foreach ( $book_contents['front-matter'] as $front_matter ) {
				if ( ! $front_matter['export'] ) {
					continue; // Skip
				}

				$data = $this->mapBookDataAndContent( $front_matter, $metadata, $index, [
					'type' => 'front_matter',
					'needs_tidy_html' => true,
					'is_epub' => true, // we want the slugs to be proper anchors in the EPUB export
				] );

				$subclass = $data['subclass'];

				if ( $compare !== $subclass ) {
					continue; //Skip
				}

				$vars['post_title'] = $front_matter['post_title'];
				$vars['post_content'] = $this->blade->render( 'export/generic-post-type', $data );

				$file_id = 'front-matter-' . sprintf( '%03s', $index );
				$filename = $this->generateFilename( $file_id, $data['slug'] );

				$this->createEpubFile( $filename, $vars );
				$this->updateManifest( $file_id, [
					'ID' => $front_matter['ID'],
					'post_title' => $front_matter['post_title'],
					'filename' => $filename,
				] );

				++$index;
			}
		}

		$this->frontMatterPos = $index;
	}

	/**
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderTitle( array $book_contents, array $metadata ): void {
		// Look for custom title-page
		$content = '';

		foreach ( $book_contents['front-matter'] as $front_matter ) {
			if ( ! $front_matter['export'] ) {
				continue; // Skip
			}

			$subclass = $this->taxonomy->getFrontMatterType( $front_matter['ID'] );

			if ( 'title-page' !== $subclass ) {
				continue; // Skip
			}

			$content = $front_matter['post_content'];
			break;
		}

		// HTML
		if ( $content ) {
			$html = $this->blade->render(
				'export/title',
				[
					'content' => $this->kneadHtml( $content, 'custom' ),
				]
			);
		} else {
			$authors = null;
			$contributors = null;

			if ( isset( $metadata['pb_authors'] ) && ! empty( $metadata['pb_authors'] ) ) {
				$authors = is_array( $metadata['pb_authors'] ) ? get_contributors_name_imploded( $metadata['pb_authors'] ) : $metadata['pb_authors'];
			}

			if ( isset( $metadata['pb_contributors'] ) && ! empty( $metadata['pb_contributors'] ) ) {
				$contributors = is_array( $metadata['pb_contributors'] ) ? get_contributors_name_imploded( $metadata['pb_contributors'] ) : $metadata['pb_contributors'];
			}

			$html = $this->blade->render(
				'export/title',
				[
					'title' => get_bloginfo( 'name' ),
					'subtitle' => $metadata['pb_subtitle'] ?? '',
					'authors' => $authors,
					'contributors' => $contributors,
					'logo' => current_theme_supports( 'pressbooks_publisher_logo' ) ? get_theme_support( 'pressbooks_publisher_logo' )[0]['logo_uri'] : null,
					'publisher' => $metadata['pb_publisher'] ?? '',
					'publisher_city' => $metadata['pb_publisher_city'] ?? '',
				]
			);
		}

		// Create file, insert into manifest
		$vars = [
			'post_title' => __( 'Title Page', 'pressbooks' ),
			'stylesheet' => $this->stylesheet,
			'post_content' => $html,
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$file_id = 'title-page';
		$filename = $this->generateFilename( $file_id );

		$this->createEpubFile( $filename, $vars );
		$this->updateManifest( $file_id, [
			'ID' => -1,
			'post_title' => $vars['post_title'],
			'filename' => $filename,
		] );
	}

	/**
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderCopyright( array $metadata ): void {
		if ( empty( $metadata['pb_book_license'] ) ) {
			$all_rights_reserved = true;
		} elseif ( $metadata['pb_book_license'] === 'all-rights-reserved' ) {
			$all_rights_reserved = true;
		} else {
			$all_rights_reserved = false;
		}
		if ( ! empty( $metadata['pb_custom_copyright'] ) ) {
			$has_custom_copyright = true;
		} else {
			$has_custom_copyright = false;
		}

		// Custom Copyright must override All Rights Reserved
		if ( ! $has_custom_copyright || ( $has_custom_copyright && ! $all_rights_reserved ) ) {
			$license = $this->doCopyrightLicense( $metadata );
			if ( $license ) {
				$license_copyright = $this->kneadHtml( $this->tidy( $license ), 'custom' );
			}
		}

		// Custom copyright
		if ( $has_custom_copyright ) {
			$custom_copyright = $this->kneadHtml( $this->tidy( $metadata['pb_custom_copyright'] ), 'custom' );
		}

		// default, so something is displayed
		$has_default = false;
		if ( empty( $metadata['pb_custom_copyright'] ) && empty( $license ) ) {
			$has_default = true;
			$default_copyright_name = get_bloginfo( 'name' ) . ' ' . __( 'Copyright', 'pressbooks' ) . ' &copy; ';
			if ( ! empty( $meta['pb_copyright_year'] ) ) {
				$default_copyright_date = $meta['pb_copyright_year'];
			} elseif ( ! empty( $meta['pb_publication_date'] ) ) {
				$default_copyright_date = date( 'Y', $meta['pb_publication_date'] );
			} else {
				$default_copyright_date = date( 'Y' );
			}
			if ( ! empty( $metadata['pb_copyright_holder'] ) ) {
				$default_copyright_holder = ' ' . __( 'by', 'pressbooks' ) . ' ' . $metadata['pb_copyright_holder'] . '. ';
			}
		}

		// Copyright
		// Please be kind, help Pressbooks grow by leaving this on!
		if ( empty( $GLOBALS['PB_SECRET_SAUCE']['TURN_OFF_FREEBIE_NOTICES_EPUB'] ) ) {
			$freebie_notice = 'This book was produced with <a href="http://pressbooks.com/">Pressbooks</a>.';
		}

		// Create file, insert into manifest

		$vars = [
			'post_title' => html_entity_decode( __( 'Copyright', 'pressbooks' ) ),
			'stylesheet' => $this->stylesheet,
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$blade_vars = [];
		if ( isset( $license_copyright ) ) {
			$blade_vars['license_copyright'] = $license_copyright;
		}
		if ( isset( $custom_copyright ) ) {
			$blade_vars['custom_copyright'] = $custom_copyright;
		}
		if ( isset( $freebie_notice ) ) {
			$blade_vars['freebie_notice'] = $freebie_notice;
		}
		if ( $has_default ) {
			$blade_vars['has_default'] = $has_default;
			$blade_vars['default_copyright_name'] = $default_copyright_name;
			$blade_vars['default_copyright_date'] = $default_copyright_date;
			if ( isset( $default_copyright_holder ) ) {
				$blade_vars['default_copyright_holder'] = $default_copyright_holder;
			}
		}

		$vars['post_content'] = $this->blade->render( 'export/copyright', $blade_vars );

		$file_id = 'copyright';
		$filename = $this->generateFilename( $file_id );

		$this->createEpubFile( $filename, $vars );
		$this->updateManifest( $file_id, [
			'ID' => -1,
			'post_title' => $vars['post_title'],
			'filename' => $filename,
		] );
	}

	/**
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderDedicationAndEpigraph( array $book_contents, array $metadata ): void {
		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$last_pos = false;
		$index = $this->frontMatterPos;

		foreach ( [ 'dedication', 'epigraph' ] as $compare ) {
			foreach ( $book_contents['front-matter'] as $front_matter ) {
				if ( ! $front_matter['export'] ) {
					continue; // Skip
				}

				$front_matter_id = $front_matter['ID'];
				$subclass = $this->taxonomy->getFrontMatterType( $front_matter_id );

				if ( $compare !== $subclass ) {
					continue; //Skip
				}

				$slug = $front_matter['post_name'];
				$title = ( get_post_meta( $front_matter_id, 'pb_show_title', true ) ? $front_matter['post_title'] : '' );
				$content = $this->kneadHtml( $front_matter['post_content'], 'front-matter', $index );

				$vars['post_title'] = $front_matter['post_title'];

				$vars['post_content'] = $this->blade->render(
					'export/dedication-epigraph', //TODO: Review if it could be consolidated in a single file
					[
						'subclass' => $subclass,
						'slug' => $slug,
						'front_matter_number' => $index,
						'title' => Sanitize\decode( $title ),
						'content' => $content,
					]
				);

				$file_id = 'front-matter-' . sprintf( '%03s', $index );
				$filename = $this->generateFilename( $file_id, $slug );

				$this->createEpubFile( $filename, $vars );
				$this->updateManifest( $file_id, [
					'ID' => $front_matter['ID'],
					'post_title' => $front_matter['post_title'],
					'filename' => $filename,
				]);

				++$index;
				$last_pos = $index;
			}
		}

		$this->frontMatterPos = $index;

		if ( $last_pos ) {
			$this->frontMatterLastPos = $last_pos - 1;
		}
	}

	/**
	 * Yields an estimated percentage slice of: 30-40
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return \Generator
	 * @throws \Exception
	 */
	protected function renderFrontMatterGenerator( array $book_contents, array $metadata ) : \Generator {
		$yield = new PercentageYield( 30, 40, count( $book_contents['front-matter'] ) );

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'append_front_matter_content' => '',
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$index = $this->frontMatterPos;
		foreach ( $book_contents['front-matter'] as $front_matter ) {
			yield from $yield->tick( $this->generatorPrefix . __( 'Exporting front matter', 'pressbooks' ) );

			if ( ! $front_matter['export'] ) {
				continue; // Skip
			}

			$data = $this->mapBookDataAndContent( $front_matter, $metadata, $index, [
				'type' => 'front_matter',
				'needs_tidy_html' => true,
				'is_epub' => true, // we want the slugs to be proper anchors in the EPUB export
			] );

			$subclass = $data['subclass'];

			if ( 'dedication' === $subclass || 'epigraph' === $subclass || 'title-page' === $subclass || 'before-title' === $subclass ) {
				continue; // Skip
			}

			if ( 'introduction' === $subclass ) {
				$this->hasIntroduction = true;
			}

			$vars['post_title'] = $front_matter['post_title'];
			$vars['post_content'] = $this->blade->render( 'export/generic-post-type', $data );

			$file_id = 'front-matter-' . sprintf( '%03s', $index );
			$filename = $this->generateFilename( $file_id, $data['slug'] );

			$this->createEpubFile( $filename, $vars );
			$this->updateManifest( $file_id, [
				'ID' => $front_matter['ID'],
				'post_title' => $front_matter['post_title'],
				'filename' => $filename,
			] );

			++$index;
		}

		$this->frontMatterPos = $index;
	}

	/**
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderPromo( array $book_contents, array $metadata ): void {
		$promo_html = apply_filters( 'pressbooks_epub_promo', '' );

		if ( $promo_html ) {
			$file_id = 'pressbooks-promo';
			$filename = $this->generateFilename( $file_id );

			$vars = [
				'post_title' => __( 'Make your own books using Pressbooks', 'pressbooks' ),
				'stylesheet' => $this->stylesheet,
				'post_content' => $this->kneadHtml( $promo_html, 'custom' ),
				'isbn' => $metadata['pb_ebook_isbn'] ?? '',
				'lang' => $this->lang,
			];

			$this->createEpubFile( $filename, $vars );
			$this->updateManifest( $file_id, [
				'ID' => -1,
				'post_title' => $vars['post_title'],
				'filename' => $filename,
			] );
		}
	}

	/**
	 * Yields an estimated percentage slice of: 40-50
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return \Generator
	 * @throws \Exception
	 */
	protected function renderPartsAndChaptersGenerator( array $book_contents, array $metadata ) : \Generator {
		$yield = new PercentageYield( 40, 50, $this->countPartsAndChapters( $book_contents ) );

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'append_chapter_content' => '',
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		// Parts, Chapters
		$chapter_index = 1;
		$chapter_position = 1;
		$part_index = 1;
		$part_position = 1;
		$parts_amount = count( $book_contents['part'] );

		foreach ( $book_contents['part'] as $part ) {
			yield from $yield->tick( $this->generatorPrefix . __( 'Exporting parts and chapters', 'pressbooks' ) );

			$invisible = get_post_meta( $part['ID'], 'pb_part_invisible', true ) === 'on';

			$part_is_introduction = false;
			$array_pos = count( $this->manifest );
			$has_chapters = false;
			$part_content = trim( $part['post_content'] );
			$part_slug = $part['post_name'];
			$part_title = $part['post_title'];

			// Should we inject the introduction class?
			if ( ! $invisible ) {
				// if it's single part and has content
				if ( $part_content && ! $this->hasIntroduction && $parts_amount === 1 ) {
					$part_is_introduction = true;
					$this->hasIntroduction = true;
				} elseif ( ! $this->hasIntroduction && $parts_amount > 1 ) {
					$part_is_introduction = true;
					$this->hasIntroduction = true;
				}
			}

			$part_number = $invisible ? '' : $part_index;

			if ( $part_content ) {
				$part_content = $this->kneadHtml( $this->preProcessPostContent( $part_content ), 'custom', $part_index );
			}

			foreach ( $part['chapters'] as $chapter ) {
				yield from $yield->tick( $this->generatorPrefix . __( 'Exporting parts and chapters', 'pressbooks' ) );

				if ( ! $chapter['export'] ) {
					continue; // Skip
				}

				$chapter_id = $chapter['ID'];
				$chapter_subclass = $this->taxonomy->getChapterType( $chapter_id );
				$chapter_slug = $chapter['post_name'];
				$chapter_title = get_post_meta( $chapter_id, 'pb_show_title', true ) ? $chapter['post_title'] : '';
				$chapter_content = $this->kneadHtml( $chapter['post_content'], 'chapter', $chapter_position );
				$append_chapter_content = $this->kneadHtml( apply_filters( 'pb_append_chapter_content', '', $chapter_id ), 'chapter', $chapter_position );
				$chapter_subtitle = trim( get_post_meta( $chapter_id, 'pb_subtitle', true ) );
				$chapter_author = $this->contributors->get( $chapter_id, 'pb_authors' );

				if ( Export::shouldParseSubsections() === true && Book::getSubsections( $chapter_id ) !== false ) {
					$chapter_content = $this->html5ToXhtml( Book::tagSubsections( $chapter_content, $chapter_id ) );
				}

				// Inject introduction class?
				if ( ! $this->hasIntroduction ) {
					$chapter_subclass .= ' introduction';
					$this->hasIntroduction = true;
				}

				$append_chapter_content .= $this->kneadHtml( $this->tidy( $this->doSectionLevelLicense( $metadata, $chapter_id ) ), 'chapter', $chapter_position );

				$chapter_number = ! str_contains( $chapter_subclass, 'numberless' ) ? $chapter_index : '';

				$vars['post_title'] = $chapter['post_title'];
				$vars['post_content'] = $this->blade->render(
					'export/chapter',
					[
						'subclass' => $chapter_subclass,
						'slug' => $chapter_slug,
						'sanitized_title' => wp_strip_all_tags( \Pressbooks\Sanitize\decode( $chapter['post_title'] ) ),
						'number' => $this->numbered ? $chapter_number : '',
						'title' => \Pressbooks\Sanitize\decode( $chapter_title ),
						'is_new_buckram' => $this->wrapHeaderElements,
						'output_short_title' => false,
						'author' => $chapter_author,
						'subtitle' => $chapter_subtitle,
						'content' => Sanitize\space_to_numerical_html_entity( $chapter_content ),
						'append_content' => $append_chapter_content,
					]
				);

				$file_id = 'chapter-' . sprintf( '%03s', $chapter_position );
				$filename = $this->generateFilename( $file_id, $chapter_slug );

				$this->createEpubFile( $filename, $vars );
				$this->updateManifest( $file_id, [
					'ID' => $chapter['ID'],
					'post_title' => $chapter['post_title'],
					'filename' => $filename,
				] );

				$has_chapters = true;

				$chapter_position++;

				if ( $chapter_number ) {
					++$chapter_index;
				}
			}

			$vars['post_title'] = $part_title;
			$vars['post_content'] = $this->blade->render(
				'export/part',
				[
					'invisibility' => $invisible ? 'invisible' : '',
					'introduction' => $part_is_introduction ? 'introduction' : '',
					'slug' => $part_slug,
					'number' => $this->numbered ? \Pressbooks\L10n\romanize( $part_number ) : '',
					'title' => \Pressbooks\Sanitize\decode( $part_title ),
					'content' => $part_content,
				]
			);

			$file_id = 'part-' . sprintf( '%03s', $part_position );
			$filename = $this->generateFilename( $file_id, $part_slug );

			if ( ( $parts_amount === 1 && $part_content ) || ( $parts_amount > 1 && ( $has_chapters || $part_content ) ) ) {
				$this->createEpubFile( $filename, $vars );

				// Insert into correct position
				$this->manifest = array_slice( $this->manifest, 0, $array_pos, true ) + [
					$file_id => [
						'ID' => $part['ID'],
						'post_title' => $part_title,
						'filename' => $filename,
					],
				] + array_slice( $this->manifest, $array_pos, count( $this->manifest ) - 1, true );

				$part_position++;

				if ( ! $invisible ) {
					++$part_index;
				}
			}

			// Did we actually inject the introduction class?
			if ( $part_is_introduction && ! $has_chapters ) {
				$this->hasIntroduction = false;
			}
		}
	}

	/**
	 * Yields an estimated percentage slice of: 50-60
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @return \Generator
	 * @throws \Exception
	 */
	protected function renderBackMatterGenerator( array $book_contents, array $metadata ) : \Generator {
		$yield = new PercentageYield( 50, 70, count( $book_contents['back-matter'] ) );

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'append_back_matter_content' => '',
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		$index = 1;
		foreach ( $book_contents['back-matter'] as $back_matter ) {
			yield from $yield->tick( $this->generatorPrefix . __( 'Exporting back matter', 'pressbooks' ) );

			if ( ! $back_matter['export'] ) {
				continue; // Skip
			}

			$data = $this->mapBookDataAndContent( $back_matter, $metadata, $index, [
				'type' => 'back_matter',
				'needs_tidy_html' => true,
				'is_epub' => true, // we want the slugs to be proper anchors in the EPUB export
			] );

			$vars['post_title'] = Sanitize\decode( $back_matter['post_title'] );
			$vars['post_content'] = $this->blade->render( 'export/generic-post-type', $data );

			$file_id = 'back-matter-' . sprintf( '%03s', $index );
			$filename = $this->generateFilename( $file_id, $data['slug'] );

			$this->createEpubFile( $filename, $vars );
			$this->updateManifest( $file_id, [
				'ID' => $back_matter['ID'],
				'post_title' => $back_matter['post_title'],
				'filename' => $filename,
			] );

			++$index;
		}

	}

	/**
	 * Uses $this->manifest to generate itself.
	 *
	 * @param array $metadata
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function renderToc( array $metadata ): void {
		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'isbn' => $metadata['pb_ebook_isbn'] ?? '',
			'lang' => $this->lang,
		];

		// Start by inserting self into correct manifest position
		$array_pos = $this->positionOfToc();

		$file_id = 'table-of-contents';
		$filename = "{$file_id}.{$this->filext}";
		$vars['post_title'] = __( 'Table Of Contents', 'pressbooks' );

		$this->manifest = array_slice( $this->manifest, 0, $array_pos + 1, true ) + [
			$file_id => [
				'ID' => -1,
				'post_title' => $vars['post_title'],
				'filename' => $filename,
			],
		] + array_slice( $this->manifest, $array_pos + 1, count( $this->manifest ) - 1, true );

		$chapters_count = 1; // Chapter count
		$parts_count = 1; // Part count
		$rendered_items = []; //TOC titles to be sent to the view

		foreach ( $this->manifest as $k => $v ) {

			$query_data = array_merge( $v, [ 'href' => $v['filename'] ] );

			if ( 0 === strpos( $k, 'part-' ) ) { //Process parts

				$data = $this->getPostInformation( 'chapter', $query_data, 'part' );

				/**
				 * Filter the label used for post types (front matter/parts/chapters/back matter) in the TOC and section headings.
				 *
				 * @since 5.6.0
				 *
				 * @param string $label
				 * @param array $args
				 *
				 * @return string Filtered label
				 */
				$is_visible = get_post_meta( $data['ID'], 'pb_part_invisible', true ) !== 'on';
				$rendered_items[] = $this->blade->render('export/bullet-toc-part', [
					'bullet_class' => 'part',
					'is_visible' => $is_visible,
					'has_content' => true, // show in TOC by default in epub
					'has_at_least_one_chapter' => true, // show in TOC by default in epub
					'item' => [
						'is_epub' => true,
						'slug' => $data['href'],
						'title' => ( $this->numbered && $is_visible ? apply_filters('pb_post_type_label', __( 'Part', 'pressbooks' ),
						[ 'post_type' => 'part' ]) . ' ' . \Pressbooks\L10n\romanize( $parts_count ) . '. ' : '' ) . $data['title'],
					],
				]);

				$parts_count = $is_visible ? ++$parts_count : $parts_count;

			} elseif ( 0 === strpos( $k, 'front-matter-' ) || 0 === strpos($k,
			'back-matter-') ) { //Process front/back matters

				$type = 0 === strpos( $k, 'front-matter-' ) ? 'front-matter' : 'back-matter';

				$matter_data = $this->getExtendedPostInformation( $type, $query_data );

				$rendered_items[] = $this->renderTocItem( $type, $matter_data, false, true );

			} elseif ( 0 === strpos( $k, 'chapter-' ) ) { //Process chapters

				$chapter_data = $this->getExtendedPostInformation( 'chapter', $query_data );

				$chapter_type = $this->taxonomy->getChapterType( $chapter_data['ID'] );

				if ( 'numberless' !== $chapter_type && $this->numbered ) {
					$chapter_data['title'] = "${chapters_count}. ${chapter_data['title']}";
					$chapters_count++;
				}

				$rendered_items[] = $this->renderTocItem( 'chapter', $chapter_data, false, true );
			}
		}

		$vars['post_content'] = $this->blade->render('export/toc', [
			'title' => __( 'Contents', 'pressbooks' ),
			'toc' => $rendered_items,
		]);

		$this->createEpubFile( $filename, $vars );
	}

	/**
	 * Determine position of TOC based on Chicago Manual Of Style.
	 *
	 * @return int
	 */
	protected function positionOfToc() {

		$search = array_keys( $this->manifest );

		if ( false === $this->frontMatterLastPos ) {

			$array_pos = array_search( 'copyright', $search, true );
			if ( false === $array_pos ) {
				$array_pos = -1;
			}
		} else {

			$array_pos = -1;
			$preg = '/^front-matter-' . sprintf( '%03s', $this->frontMatterLastPos ) . '$/';
			foreach ( $search as $key => $val ) {
				if ( preg_match( $preg, $val ) ) {
					$array_pos = $key;
					break;
				}
			}
		}

		return $array_pos;
	}

	/**
	 * Pummel the HTML into EPUB compatible dough.
	 *
	 * @param string $html
	 * @param string $type front-matter, part, chapter, back-matter, ...
	 * @param int $pos (optional) position of content, used when creating filenames like: chapter-001, chapter-002, ...
	 *
	 * @return string
	 */
	protected function kneadHtml( string $html, string $type, int $pos = 0 ): string {
		$html5 = new HtmlParser();
		$dom = $html5->loadHTML( $html, [ 'disable_html_ns' => true ] ); // Disable default namespace for \DOMXPath compatibility

		// Download images, change to relative paths
		$dom = $this->scrapeAndKneadImages( $dom );

		// Download audio files, change to relative paths
		$dom = $this->scrapeAndKneadMedia( $dom );

		// Deal with <a href="">, <a href=''>, and other mutations
		$dom = $this->kneadHref( $dom, $type, $pos );

		// Make sure empty tags (e.g. <b></b>) don't get turned into self-closing versions by adding an empty text node to them.
		$xpath = new \DOMXPath( $dom );
		while ( ( $nodes = $xpath->query( '//*[not(text() or node() or self::br or self::hr or self::img)]' ) ) && $nodes->length > 0 ) { // @codingStandardsIgnoreLine
			foreach ( $nodes as $node ) {
				/** @var \DOMElement $node */
				$node->appendChild( new \DOMText( '' ) );
			}
		}

		// If you are storing multi-byte characters in XML, then saving the XML using saveXML() will create problems.
		// Ie. It will spit out the characters converted in encoded format. Instead do the following:
		$html = $dom->saveXML( $dom->documentElement );

		// Remove pb_fixme wrapper and remove auto-created <html> <body> and <!DOCTYPE> tags.
		return $html5->removeFixMeWrapper( \Pressbooks\Sanitize\strip_container_tags( $html ) );
	}

	/**
	 * Parse HTML snippet, download all found <img> tags into /EPUB/assets/, return the HTML with changed <img> paths.
	 *
	 * @param \DOMDocument $doc
	 *
	 * @return \DOMDocument
	 */
	protected function scrapeAndKneadImages( \DOMDocument $doc ): \DOMDocument {
		$fullpath = $this->tmpDir . '/EPUB/assets';

		$images = $doc->getElementsByTagName( 'img' );
		foreach ( $images as $image ) {
			/** @var \DOMElement $image */
			// Fetch image, change src
			$url = $image->getAttribute( 'src' );
			// Replace Buckram SVGs with PNGs
			if ( str_starts_with( $url, get_template_directory_uri() . '/packages/buckram/assets/images' ) && str_ends_with( $url, '.svg' ) ) {
				$url = str_replace( '.svg', '.png', $url );
			}
			$filename = $this->fetchAndSaveUniqueImage( $url, $fullpath );
			if ( $filename ) {
				// Replace with new image
				$image->setAttribute( 'src', 'assets/' . $filename );
			} else {
				// Tag broken image
				$image->setAttribute( 'src', "{$url}#fixme" );
			}
		}

		return $doc;
	}

	/**
	 * Fetch an image with wp_remote_get(), save it to $fullpath with a unique name.
	 * Will return an empty string if something went wrong.
	 *
	 * @param $url string
	 * @param $fullpath string
	 *
	 * @return string filename
	 */
	protected function fetchAndSaveUniqueImage( string $url, string $fullpath ): string {
		if ( isset( $this->fetchedImageCache[ $url ] ) ) {
			return $this->fetchedImageCache[ $url ];
		}

		$args = [
			'timeout' => $this->timeout,
		];

		$response = \Pressbooks\Utility\remote_get_retry( $url, $args );

		// WordPress error?
		if ( is_wp_error( $response ) ) {
			try {
				// protocol relative urls handed to wp_remote_get will fail
				// try adding a protocol
				$protocol_relative = wp_parse_url( $url );
				if ( ! isset( $protocol_relative['scheme'] ) ) {
					if ( true === is_ssl() ) {
						$url = 'https:' . $url;
					} else {
						$url = 'http:' . $url;
					}
				}
				$response = wp_remote_get( $url, $args );
				if ( is_wp_error( $response ) ) {
					throw new \Exception( 'Bad URL: ' . $url );
				}
			} catch ( \Exception $exc ) {
				$this->fetchedImageCache[ $url ] = '';
				debug_error_log( '\PressBooks\Export\Epub\fetchAndSaveUniqueImage wp_error on wp_remote_get() - ' . $response->get_error_message() . ' - ' . $exc->getMessage() );
				return '';
			}
		}

		// Basename without query string
		$filename = explode( '?', basename( $url ) );

		/**
		 * @since 5.5.0
		 *
		 * Filters the filename of a unique image
		 *
		 * @param string $filename the filename
		 * @param array $ori_filename the original filename
		 * @param object $response the response
		 * @param string $url the url
		 */
		$unique_filename = apply_filters( 'pb_epub201_fetchandsaveuniqueimage_filename', '', $filename, $response, $url );

		if ( '' !== $unique_filename ) {
			$filename = $unique_filename;
		} else {
			// isolate latex image service, add file extension
			if ( PB_MATHJAX_URL && str_starts_with( $url, PB_MATHJAX_URL ) ) {
				$filename = md5( array_pop( $filename ) );
				// content-type = 'image/png'
				$type = explode( '/', $response['headers']['content-type'] );
				$type = array_pop( $type );
				$filename .= '.' . $type;
			} else {
				$filename = array_shift( $filename );
				$filename = explode( '#', $filename )[0]; // Remove trailing anchors
				$filename = sanitize_file_name( urldecode( $filename ) );
				$filename = Sanitize\force_ascii( $filename );
			}
		}

		// A book with a lot of images can trigger "Fatal Error Too many open files" because tmpfiles are not closed until PHP exits
		// Use a $resource_key so we can close the tmpfile ourselves
		$resource_key = uniqid( 'tmpfile-epub-', true );
		$tmp_file = \Pressbooks\Utility\create_tmp_file( $resource_key );

		\Pressbooks\Utility\put_contents( $tmp_file, wp_remote_retrieve_body( $response ) );

		if ( ! \Pressbooks\Image\is_valid_image( $tmp_file, $filename ) ) {
			$this->fetchedImageCache[ $url ] = '';
			debug_error_log( '\PressBooks\Export\Epub\fetchAndSaveUniqueImage is_valid_image, not a valid image ' );
			fclose( $GLOBALS[ $resource_key ] ); // @codingStandardsIgnoreLine
			return ''; // Not an image
		}

		if ( $this->compressImages ) {
			/**
			 * @since 5.5.0
			 *
			 * Filters if a image should be compressed
			 *
			 * @param boolean $compress should it be compressed
			 * @param file $tmp_file the temp file
			 */
			if ( apply_filters( 'pb_epub201_fetchandsaveuniqueimage_compress', true, $tmp_file ) ) {
				$format = explode( '.', $filename );
				$format = strtolower( end( $format ) ); // Extension
				try {
					\Pressbooks\Image\resize_down( $format, $tmp_file );
				} catch ( \Exception $e ) {
					return '';
				}
			}
		}

		// Check for duplicates, save accordingly
		if ( ! file_exists( "$fullpath/$filename" ) ) {
			copy( $tmp_file, "$fullpath/$filename" );
		} elseif ( md5( \Pressbooks\Utility\get_contents( $tmp_file ) ) !== md5( \Pressbooks\Utility\get_contents( "$fullpath/$filename" ) ) ) {
			$filename = wp_unique_filename( $fullpath, $filename );
			copy( $tmp_file, "$fullpath/$filename" );
		}
		fclose( $GLOBALS[ $resource_key ] ); // @codingStandardsIgnoreLine

		$this->fetchedImageCache[ $url ] = $filename;
		return $filename;
	}

	/**
	 * Fetch a font with wp_remote_get(), save it to $fullpath with a unique name.
	 * Will return an empty string if something went wrong.
	 *
	 * @param $url string
	 * @param $fullpath string
	 *
	 * @return string filename
	 */
	protected function fetchAndSaveUniqueFont( string $url, string $fullpath ): string {
		if ( isset( $this->fetchedFontCache[ $url ] ) ) {
			return $this->fetchedFontCache[ $url ];
		}

		$args = [];

		if ( defined( 'WP_ENV' ) && WP_ENV === 'development' ) {
			$args['sslverify'] = false;
		}

		$response = wp_remote_get(
			$url,
			array_merge(
				[
					'timeout' => $this->timeout,
				],
				$args
			)
		);

		// WordPress error?
		if ( is_wp_error( $response ) ) {
			// TODO: Properly handle errors returned via $response->get_error_message();
			$this->fetchedFontCache[ $url ] = '';
			return '';
		}

		// if it is a Google font, we could get the actual font name
		if ( str_contains( $url, 'fonts.googleapis.com' ) ) {
			$patterns = [
				'!^https://fonts.googleapis.com/css\?!',
				'!(family=[^&:]+).*$!',
				'!family=!',
				'/[^A-Za-z0-9\-]/',
			];
			$replacements = [
				'',
				'$1',
				'',
				' ',
			];
			$filename = preg_replace( $patterns, $replacements, $url ) . '.css';
		} else {
			// Basename without query string
			$filename = explode( '?', basename( $url ) );
			$filename = array_shift( $filename );
		}

		$filename = sanitize_file_name( urldecode( $filename ) );
		$filename = Sanitize\force_ascii( $filename );

		$tmp_file = \Pressbooks\Utility\create_tmp_file();
		\Pressbooks\Utility\put_contents( $tmp_file, wp_remote_retrieve_body( $response ) );

		// TODO: Validate that this is actually a font
		// TODO: Refactor fetchAndSaveUniqueImage() and fetchAndSaveUniqueFont() into a single method, but "inject" different validation

		// Check for duplicates, save accordingly
		if ( ! file_exists( "$fullpath/$filename" ) ) {
			copy( $tmp_file, "$fullpath/$filename" );
		} elseif ( md5( \Pressbooks\Utility\get_contents( $tmp_file ) ) !== md5( \Pressbooks\Utility\get_contents( "$fullpath/$filename" ) ) ) {
			$filename = wp_unique_filename( $fullpath, $filename );
			copy( $tmp_file, "$fullpath/$filename" );
		}

		$this->fetchedFontCache[ $url ] = $filename;
		return $filename;
	}

	/**
	 * Parse HTML snippet, download all found <audio>, <video> and <source> tags
	 * into /EPUB/assets/, return the HTML with changed 'src' paths.
	 *
	 * @param \DOMDocument $doc
	 *
	 * @return \DOMDocument
	 */
	protected function scrapeAndKneadMedia( \DOMDocument $doc ): \DOMDocument {
		$fullpath = $this->tmpDir . '/EPUB/assets';
		$tags = [ 'source', 'audio', 'video' ];

		foreach ( $tags as $tag ) {

			$sources = $doc->getElementsByTagName( $tag );
			foreach ( $sources as $source ) {
				/** @var $source \DOMElement */
				if ( ! empty( $source->getAttribute( 'src' ) ) ) {
					// Fetch the audio file
					$url = $source->getAttribute( 'src' );
					$filename = $this->fetchAndSaveUniqueMedia( $url, $fullpath );

					if ( $filename ) {
						// Change src to new relative path
						$source->setAttribute( 'src', 'assets/' . $filename );
					} else {
						// Tag broken media
						$source->setAttribute( 'src', "{$url}#fixme" );
					}
				}
			}
		}

		return $doc;
	}

	/**
	 * Change hrefs
	 *
	 * @param \DOMDocument $doc
	 * @param string $type front-matter, part, chapter, back-matter, ...
	 * @param int $pos (optional) position of content, used when creating filenames like: chapter-001, chapter-002, ...
	 *
	 * @return \DOMDocument
	 */
	protected function kneadHref( \DOMDocument $doc, string $type, int $pos ): \DOMDocument {
		$urls = $doc->getElementsByTagName( 'a' );
		foreach ( $urls as $url ) {
			/** @var \DOMElement $url */
			$current_url = '' . $url->getAttribute( 'href' ); // Stringify

			// Is this the the attributionUrl?
			if ( $url->getAttribute( 'rel' ) === 'cc:attributionURL' ) {
				$url->parentNode->replaceChild(
					$doc->createTextNode( $url->nodeValue ),
					$url
				);
				continue;
			}

			// Don't touch empty urls
			if ( ! trim( $current_url ) ) {
				continue;
			}

			// WordPress auto wraps images in a href tags.
			// For example: <a href="some_image-original.png"><img src="some_image-300x200.png" /></a>
			// This causes an EPUB validation error of: hyperlink to non-standard resource ( of type 'image/...' )
			// We fix this by removing the href
			if ( $url->childNodes->length ) {
				foreach ( $url->childNodes as $node ) {
					/** @var \DOMElement $node */
					if ( 'img' === $node->nodeName && $this->fuzzyImageNameMatch( $current_url, $node->getAttribute( 'src' ) ) ) {
						$url->removeAttribute( 'href' );
						continue 2;
					}
				}
			}

			// Determine if we are trying to link to our own internal content
			$internal_url = $this->fuzzyHrefMatch( $current_url, $pos );
			if ( false !== $internal_url ) {
				$url->setAttribute( 'href', $internal_url );
				continue;
			}

			// Canonicalize, fix typos, remove garbage
			if ( isset( $current_url[0] ) && '#' !== $current_url[0] ) {
				$url->setAttribute( 'href', \Pressbooks\Sanitize\canonicalize_url( $current_url ) );
			}
		}

		return $doc;
	}

	/**
	 * Fuzzy image name match.
	 * For example: <a href="Some_Image-original.png"><img src="some_image-300x200.PNG" /></a>
	 * We consider both 'href' and 'src' above 'the same'
	 *
	 * @param string $file1
	 * @param string $file2
	 *
	 * @return bool
	 */
	protected function fuzzyImageNameMatch( string $file1, string $file2 ): bool {
		$file1 = basename( $file1 );
		$file2 = basename( $file2 );

		/* Compare extensions */

		$file1 = explode( '.', $file1 );
		$ext1 = strtolower( end( $file1 ) );

		$file2 = explode( '.', $file2 );
		$ext2 = strtolower( end( $file2 ) );

		if ( $ext1 !== $ext2 ) {
			return false;
		}

		/* Compare prefixes */

		$pre1 = explode( '-', $file1[0] );
		$pre1 = strtolower( $pre1[0] );

		$pre2 = explode( '-', $file2[0] );
		$pre2 = strtolower( $pre2[0] );

		if ( $pre1 !== $pre2 ) {
			return false;
		}

		return true;
	}

	/**
	 * Try to determine if a URL is pointing to internal content.
	 *
	 * @param string $url
	 * @param int $pos (optional) position of content, used when creating filenames like: chapter-001, chapter-002, ...
	 *
	 * @return bool|string
	 */
	protected function fuzzyHrefMatch( string $url, int $pos ) {
		if ( ! $pos ) {
			return false;
		}

		$url = trim( $url );
		// Remove trailing slash
		$url = rtrim( $url, '/' );
		// Change /foo/bar/#fragment to /foo/bar#fragment
		if ( preg_match( '~/#[^/]*$~', $url ) ) {
			$url = str_lreplace( '/#', '#', $url );
		}

		$domain = wp_parse_url( $url );
		$domain = $domain['host'] ?? false;

		if ( $domain ) {
			$guess_url = site_url();
			if ( ! $guess_url ) {
				$guess_url = wp_guess_url();
			}
			$domain2 = wp_parse_url( $guess_url );
			$domain2 = $domain2['host'] ?? false;
			if ( $domain2 !== $domain ) {
				return false; // If there is a domain name and it =/= ours, bail.
			}
		}

		$split_url = explode( '/', $url );
		$last_pos = count( $split_url ) - 1;
		$posttype = $split_url[ $last_pos - 1 ] ?? false;
		$anchor = '';

		// Guess the slug
		if ( $last_pos > 0 && '#' === substr( trim( $split_url[ $last_pos ] ), 0, 1 ) ) {
			$anchor = trim( $split_url[ $last_pos ] ); // Found an #anchor
			$slug = trim( $split_url[ $last_pos - 1 ] );
		} elseif ( false !== strpos( $split_url[ $last_pos ], '#' ) ) {
			[ $slug, $anchor ] = explode( '#', $split_url[ $last_pos ] ); // Found an #anchor
			$anchor = trim( "#{$anchor}" );
			$slug = trim( $slug );
		} else {
			$slug = trim( $split_url[ $last_pos ] );
		}

		if ( ! $slug ) {
			return false;
		}

		// Check if an anchor (ie. #fragment) is considered external, don't change the URL if we find a match
		$external_anchors = [ \Pressbooks\Interactive\Content::ANCHOR ];
		if ( in_array( $anchor, $external_anchors, true ) ) {
			return false;
		}

		// Cheap cache
		static $lookup = false;
		static $order = false;
		if ( $lookup === false && $order === false ) {
			$lookup = Book::getBookStructure();
			$order = $this->fixOrder( $lookup['__order'] );
		}

		$found = [];
		foreach ( $lookup['__order'] as $post_id => $val ) {
			if (
				$val['post_type'] === $posttype &&
				$val['post_name'] === $slug &&
				$val['export']
			) {
				$found = array_merge( [ 'ID' => $post_id ], $val ); // @codingStandardsIgnoreLine
			}
		}
		if ( empty( $found ) ) {
			return false;
		}

		// Create a new url that points to a file in the epub
		$new_url = '';
		if ( 'part' === $posttype ) {
			// Handle parts
			foreach ( $lookup['part'] as $key => $part ) {
				if ( $part['post_name'] === $slug ) {
					$new_url = 'part-' . sprintf( '%03s', $key + 1 ) . '-' . ( $this->sanitizedSlugs[ $slug ] ?? $slug ) . ".{$this->filext}";
				}
			}
		} else {
			$new_pos = 0;
			foreach ( $order as $post_id => $val ) {
				if ( (string) $val['post_type'] === (string) $found['post_type'] && $val['export'] ) {
					if ( $this->taxonomy->getFrontMatterType( $post_id ) !== 'title-page' ) {
						// Custom title pages aren't numbered.
						++$new_pos;
					}
				}
				if ( (int) $post_id === (int) $found['ID'] ) {
					break;
				}
			}
			if ( $val['post_type'] === 'front-matter' && $this->taxonomy->getFrontMatterType( $post_id ) === 'title-page' ) {
				$new_url = "title-page.{$this->filext}";
			} else {
				$new_url = "{$found['post_type']}-" . sprintf( '%03s', $new_pos ) . '-' . ( $this->sanitizedSlugs[ $slug ] ?? $slug ) . ".{$this->filext}";
			}
		}
		if ( $anchor ) {
			$new_url .= $anchor;
		}

		return $new_url;
	}

	/**
	 * Reorder the book structure to conform to Chicago Style, so that the
	 * book begins with Before Title, Title Page, Dedication, Epigraph.
	 *
	 * @param array $order
	 * @return array
	 */
	protected function fixOrder( array $order ): array {
		$fixed = [];
		$fm = [];
		foreach ( $order as $post_id => $val ) {
			if ( $val['post_type'] === 'front-matter' ) {
				$type = $this->taxonomy->getFrontMatterType( $post_id );
				if ( ! in_array( $type, [ 'before-title', 'title-page', 'dedication', 'epigraph' ], true ) ) {
					// Add front matter that isn't being reorderd without intervention.
					$fixed[ $post_id ] = $val;
				} else {
					// Add front matter that is being reordered to temporary array.
					$fm[ $post_id ] = array_merge( $val, [ 'type' => $type ] );
				}
			} else {
				// Add parts, chapters, and back matter without intervention.
				$fixed[ $post_id ] = $val;
			}
		}
		// Work our way backwards, starting with epigraph
		foreach ( [ 'epigraph', 'dedication', 'title-page', 'before-title' ] as $type ) {
			foreach ( $fm as $post_id => $val ) {
				if ( $val['type'] === $type ) {
					$fixed = [ $post_id => $val ] + $fixed;
					break;
				}
			}
		}
		return $fixed;
	}

	/**
	 * Create OPF File.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @throws \Exception
	 */
	protected function createOPF( array $book_contents, array $metadata ): void {
		if ( empty( $this->manifest ) ) {
			throw new \Exception( '$this->manifest cannot be empty. Did you forget to call $this->createEPUB() ?' );
		}

		$vars = [
			'manifest' => $this->manifest,
			'stylesheet' => $this->stylesheet,
			'lang' => $this->lang,
		];

		$vars['manifest_assets'] = $this->buildManifestAssetsHtml();

		$vars['do_copyright_license'] = sanitize_xml_attribute(
			wp_strip_all_tags( $this->doCopyrightLicense( $metadata ), true )
		);

		// Loop through the html files for the manifest and assemble them. Assign properties based on their content.
		$html = '';
		foreach ( $this->manifest as $k => $v ) {
			$properties = $this->getProperties( $this->epubDir . '/' . $v['filename'] );

			array_key_exists( 'mathml', $properties ) ? $mathml = 'properties="mathml" ' : $mathml = '';
			array_key_exists( 'scripted', $properties ) ? $scripted = 'properties="scripted" ' : $scripted = '';

			$html .= sprintf( '<item id="%s" href="%s" %s%smedia-type="application/xhtml+xml" />', $k, $v['filename'], $mathml, $scripted ) . "\n\t\t";
		}
		$vars['manifest_filelist'] = $html;

		// Sanitize metadata for usage in XML template
		foreach ( $metadata as $key => $val ) {
			if ( is_array( $val ) ) {
				$items = [];
				foreach ( $val as $item ) {
					if ( isset( $item['name'] ) ) {
						$items[] = sanitize_xml_attribute( $item['name'] );
					}
				}
				if ( ! empty( $items ) ) {
					$metadata[ $key ] = implode_add_and( ';', $items );
				}
			} else {
				$metadata[ $key ] = sanitize_xml_attribute( $val );
				if ( $this->contributors->isValid( $key ) ) {
					$contributors = decode( $metadata[ $key ], false );
					$metadata[ $key ] = array_map(
						'\Pressbooks\Sanitize\encode_ampersand',
						explode_remove_and( ';', $contributors )
					);
				}
			}
		}
		$vars['meta'] = $metadata;

		// Put contents
		$this->createEpubFile( 'book.opf', $vars, [ 'template' => 'opf' ] );
	}

	/**
	 * Find all the image files, insert them into the OPF file
	 *
	 * @return string
	 */
	protected function buildManifestAssetsHtml(): string {
		$html = '';
		$assets = scandir( $this->assetsDir );
		$used_ids = [];

		foreach ( $assets as $asset ) {
			if ( '.' === $asset || '..' === $asset ) {
				continue;
			}
			$mimetype = $this->mediaType( "$this->assetsDir/$asset" );
			if ( $this->coverImage === $asset ) {
				$file_id = 'cover-image';
			} else {
				$file_id = 'media-' . pathinfo( "$this->assetsDir/$asset", PATHINFO_FILENAME );
				$file_id = Sanitize\sanitize_xml_id( $file_id );
			}

			// Check if a media id has already been used, if so give it a new one
			$check_if_used = $file_id;
			for ( $i = 2; $i <= 999; $i++ ) {
				if ( empty( $used_ids[ $check_if_used ] ) ) {
					break;
				} else {
					$check_if_used = $file_id . "-$i";
				}
			}
			$file_id = $check_if_used;

			$html .= sprintf( '<item id="%s" href="assets/%s" media-type="%s" />', $file_id, $asset, $mimetype ) . "\n";

			$used_ids[ $file_id ] = true;
		}

		return $html;
	}

	/**
	 * Create NCX file.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @throws \Exception
	 */
	protected function createNCX( array $book_contents, array $metadata ): void {
		if ( empty( $this->manifest ) ) {
			throw new \Exception( '$this->manifest cannot be empty. Did you forget to call $this->createEPUB() ?' );
		}

		// TODO: this seems to not be used anywhere
		$authors = '';
		if ( isset( $metadata['pb_authors'] ) && ! empty( $metadata['pb_authors'] ) ) {
			if ( is_array( $metadata['pb_authors'] ) ) {
				$authors = get_contributors_name_imploded( $metadata['pb_authors'] );
			} elseif ( is_string( $metadata['pb_authors'] ) ) {
				$authors = $metadata['pb_authors'];
			}
		}

		// Sanitize variables for usage in XML template
		$vars = [
			'author' => sanitize_xml_attribute( $authors ),
			'manifest' => $this->manifest,
			'manifest_keys' => array_keys( $this->manifest ),
			'dtd_uid' => ! empty( $metadata['pb_ebook_isbn'] ) ? sanitize_xml_attribute( $metadata['pb_ebook_isbn'] ) : sanitize_xml_attribute( get_bloginfo( 'url' ) ),
			'enable_external_identifier' => false,
			'lang' => $this->lang,
		];

		$this->createEpubFile( $this->generateFilename( 'toc' ), $vars, [ 'template' => 'toc' ] );
	}

	/**
	 * Dependency check.
	 *
	 * @return bool
	 */
	static function hasDependencies(): bool {
		if ( false !== \Pressbooks\Utility\check_epubcheck_install() ) {
			return true;
		}

		return false;
	}

	/**
	 * Write a file to the temporary EPUB directory.
	 *
	 * @param string $filename
	 * @param array|string $data
	 * @param array $options (optional)
	 *
	 * @return void
	 * @throws \Exception
	 */
	protected function createEpubFile( string $filename, $data, array $options = [] ): void {
		$directory = $options['directory'] ?? $this->epubDir;
		$template = $options['template'] ?? 'html';

		$path = "{$directory}/{$filename}";

		if ( ! is_array( $data ) ) {
			\Pressbooks\Utility\put_contents( $path, $data );

			return;
		}

		\Pressbooks\Utility\put_contents( $path, $this->blade->render( "export/epub/{$template}", $data ) );
	}

	/**
	 * @param string $file_id
	 * @param string $slug
	 * @return string
	 */
	protected function generateFilename( string $file_id, string $slug = '' ): string {
		return $slug
			? $file_id . '-' . $slug . '.' . $this->filext
			: $file_id . '.' . $this->filext;
	}

	/**
	 * @param string $file_id
	 * @param array $data
	 */
	protected function updateManifest( string $file_id, array $data ): void {
		$this->manifest[ $file_id ] = $data;
	}
}
