<?php
/**
 * EPUB Export class.
 *
 * @package Pressbooks
 * @author  Pressbooks <code@pressbooks.com>
 * @license GPLv2 (or any later version)
 */

namespace Pressbooks\Modules\Export\Epub;

use Pressbooks\Modules\Export\Export;
use Pressbooks\Container;
use Pressbooks\Sanitize;
use function \Pressbooks\Sanitize\sanitize_xml_attribute;
use function \Pressbooks\Utility\str_ends_with;

class Epub201 extends Export {

	/**
	 * @var array
	 */
	protected $fetchedImageCache = [];

	/**
	 * @var array
	 */
	protected $fetchedFontCache = [];

	/**
	 * Timeout in seconds.
	 * Used with wp_remote_get()
	 *
	 * @var int
	 */
	public $timeout = 90;


	/**
	 * @var string
	 */
	protected $stylesheet;


	/**
	 * @var bool
	 */
	protected $numbered = false;


	/**
	 * Temporary directory used to build EPUB, no trailing slash!
	 *
	 * @var string
	 */
	protected $tmpDir;

	/**
	 * Generated by createOEPBS(), used by createToc(), createOPF(), and creatdNCX()
	 * Note: Only XHTML files go in the manifest array (images  are done automatically)
	 *
	 * @var array
	 */
	protected $manifest = [];


	/**
	 * We forcefully reorder some of the front-matter types to respect the Chicago Manual of Style.
	 * Keep track of where we are using this variable.
	 *
	 * @var int
	 */
	protected $frontMatterPos = 1;


	/**
	 * Last known front matter position. Used to insert the TOC in the correct place.
	 *
	 * @var int|bool
	 */
	protected $frontMatterLastPos = false;


	/**
	 * Sometimes the user will omit an introduction so we must inject the style in either the first
	 * part or the first chapter ourselves.
	 *
	 * @var bool
	 */
	protected $hasIntroduction = false;

	/**
	 * Used to set cover-image in OPF for kindlegen compatibility.
	 *
	 * @var string
	 */
	protected $coverImage;


	/**
	 * Fullpath to book CSS file.
	 *
	 * @var string
	 */
	protected $exportStylePath;


	/**
	 * CSS overrides
	 *
	 * @var string
	 */
	protected $cssOverrides;


	/**
	 * Used by HtmLawed with $GLOBALS['hl_Ids']
	 *
	 * @var array
	 */
	protected $fixme;


	/**
	 * @var bool
	 */
	protected $compressImages = false;


	/**
	 * @var string
	 */
	protected $filext = 'html';


	/**
	 * $var string
	 */
	protected $dir = __DIR__;

	/**
	 * $var string
	 */
	protected $suffix = '.epub';

	/**
	 * Main language of document, two letter code
	 *
	 * @var string
	 */
	protected $lang = 'en';

	/**
	 * Regular expression for supported images (used in #($supportedImageExtensions)#i')
	 *
	 * @var string
	 */
	protected $supportedImageExtensions = '\.jpe?g|\.gif|\.png';

	/**
	 * Regular expression for supported fonts  (used in #($supportedFontExtensions)#i')
	 *
	 * @var string
	 */
	protected $supportedFontExtensions = '\.ttf|\.otf';

	/**
	 * Extra CSS (to be used by child classes if necessary)
	 *
	 * @var string
	 */
	protected $extraCss = null;


	/**
	 * @param array $args
	 */
	function __construct( array $args ) {

		// Some defaults

		if ( ! class_exists( '\PclZip' ) ) {
			require_once( ABSPATH . 'wp-admin/includes/class-pclzip.php' );
		}

		if ( ! defined( 'PB_EPUBCHECK_COMMAND' ) ) {
			define( 'PB_EPUBCHECK_COMMAND', '/usr/bin/epubcheck' );
		}

		$this->tmpDir = $this->createTmpDir();
		$this->exportStylePath = $this->getExportStylePath( 'epub' );

		$this->themeOptionsOverrides();

		// HtmLawed: id values not allowed in input
		foreach ( $this->reservedIds as $val ) {
			$this->fixme[ $val ] = 1;
		}
	}


	/**
	 * Delete temporary directory when done.
	 */
	function __destruct() {

		$this->deleteTmpDir();
	}


	/**
	 * Create $this->outputPath
	 *
	 * @return bool
	 */
	function convert() {

		// Sanity check

		if ( empty( $this->tmpDir ) || ! is_dir( $this->tmpDir ) ) {
			$this->logError( '$this->tmpDir must be set before calling convert().' );

			return false;
		}

		if ( empty( $this->exportStylePath ) || ! is_file( $this->exportStylePath ) ) {
			$this->logError( '$this->exportStylePath must be set before calling convert().' );

			return false;
		}

		// Convert

		$metadata = \Pressbooks\Book::getBookInformation();
		$book_contents = $this->preProcessBookContents( \Pressbooks\Book::getBookContents() );

		// Set two letter language code
		if ( isset( $metadata['pb_language'] ) ) {
			list( $this->lang ) = explode( '-', $metadata['pb_language'] );
		}

		try {

			$this->createContainer();
			$this->createOEPBS( $book_contents, $metadata );
			$this->createOPF( $book_contents, $metadata );
			$this->createNCX( $book_contents, $metadata );

		} catch ( \Exception $e ) {
			$this->logError( $e->getMessage() );

			return false;
		}

		$filename = $this->timestampedFileName( $this->suffix );
		if ( ! $this->zipEpub( $filename ) ) {
			return false;
		}
		$this->outputPath = $filename;

		return true;
	}


	/**
	 * Check the sanity of $this->outputPath
	 *
	 * @return bool
	 */
	function validate() {

		// Epubcheck command, (quiet flag requires version 3.0.1+)
		$command = PB_EPUBCHECK_COMMAND . ' -q ' . escapeshellcmd( $this->outputPath ) . ' 2>&1';

		// Execute command
		$output = [];
		$return_var = 0;
		exec( $command, $output, $return_var );

		// Is this a valid Epub?
		if ( ! empty( $output ) ) {
			$this->logError( implode( "\n", $output ) );

			return false;
		}

		return true;
	}


	/**
	 * Fix annoying characters that the user probably didn't do on purpose
	 *
	 * @param string $html
	 *
	 * @return string
	 */
	function fixAnnoyingCharacters( $html ) {

		// Do parent first
		$html = parent::fixAnnoyingCharacters( $html );

		// EPUB specific

		// Adobe Digital Editions has problems with exotic dashes, that is to say if this were 1999...
		// TODO: Some users want this, others do not want this, make up your mind...
		// $html = str_replace( array( '–', '&#8211;', '—', '&#8212;', '‑' ), '-', $html ); @codingStandardsIgnoreLine

		return $html;
	}


	/**
	 * Override mimeType, get rid of '; charset=binary'
	 *
	 * @param string $file
	 *
	 * @return mixed|string
	 */
	function mediaType( $file ) {

		$mime = static::mimeType( $file );
		$mime = explode( ';', $mime );
		$mime = trim( $mime[0] );

		return $mime;
	}


	/**
	 * Override based on Theme Options
	 */
	protected function themeOptionsOverrides() {

		// --------------------------------------------------------------------
		// CSS

		$css = '';
		$this->cssOverrides = apply_filters( 'pb_epub_css_override', $css ) . "\n";

		// --------------------------------------------------------------------
		// Hacks

		$hacks = [];
		$hacks = apply_filters( 'pb_epub_hacks', $hacks );

		// Display chapter numbers?
		if ( isset( $hacks['chapter_numbers'] ) && $hacks['chapter_numbers'] ) {
			$this->numbered = true;
		} else {
			$this->numbered = false;
		}

		if ( isset( $hacks['ebook_compress_images'] ) && $hacks['ebook_compress_images'] ) {
			$this->compressImages = true;
		}

	}


	/**
	 * @param $book_contents
	 *
	 * @return mixed
	 */
	protected function preProcessBookContents( $book_contents ) {

		// We need to change global $id for shortcodes, the_content, ...
		global $id;
		$old_id = $id;

		// Do root level structures first.
		foreach ( $book_contents as $type => $struct ) {

			if ( preg_match( '/^__/', $type ) ) {
				continue; // Skip __magic keys
			}

			foreach ( $struct as $i => $val ) {

				if ( isset( $val['post_content'] ) ) {
					$id = $val['ID'];
					$book_contents[ $type ][ $i ]['post_content'] = $this->preProcessPostContent( $val['post_content'] );
				}
				if ( isset( $val['post_title'] ) ) {
					$book_contents[ $type ][ $i ]['post_title'] = sanitize_xml_attribute( $val['post_title'] );
				}
				if ( isset( $val['post_name'] ) ) {
					$book_contents[ $type ][ $i ]['post_name'] = $this->preProcessPostName( $val['post_name'] );
				}

				if ( 'part' === $type ) {

					// Do chapters, which are embedded in part structure
					foreach ( $book_contents[ $type ][ $i ]['chapters'] as $j => $val2 ) {

						if ( isset( $val2['post_content'] ) ) {
							$id = $val2['ID'];
							$book_contents[ $type ][ $i ]['chapters'][ $j ]['post_content'] = $this->preProcessPostContent( $val2['post_content'] );
						}
						if ( isset( $val2['post_title'] ) ) {
							$book_contents[ $type ][ $i ]['chapters'][ $j ]['post_title'] = sanitize_xml_attribute( $val2['post_title'] );
						}
						if ( isset( $val2['post_name'] ) ) {
							$book_contents[ $type ][ $i ]['chapters'][ $j ]['post_name'] = $this->preProcessPostName( $val2['post_name'] );
						}
					}
				}
			}
		}

		$id = $old_id;
		return $book_contents;
	}


	/**
	 * @param string $content
	 *
	 * @return string
	 */
	protected function preProcessPostContent( $content ) {

		$content = apply_filters( 'the_content', $content );
		$content = $this->fixAnnoyingCharacters( $content );
		$content = $this->tidy( $content );

		return $content;
	}


	/**
	 * Tidy HTML
	 *
	 * @param string $html
	 *
	 * @return string
	 */
	protected function tidy( $html ) {

		// Make XHTML 1.1 strict using htmlLawed

		$config = [
			'valid_xhtml' => 1,
			'no_deprecated_attr' => 2,
			'unique_ids' => 'fixme-',
			'deny_attribute' => 'itemscope,itemtype,itemref,itemprop',
			'hook' => '\Pressbooks\Sanitize\html5_to_xhtml11',
			'tidy' => -1,
			'comment' => 1,
		];

		// Reset on each htmLawed invocation
		unset( $GLOBALS['hl_Ids'] );
		if ( ! empty( $this->fixme ) ) {
			$GLOBALS['hl_Ids'] = $this->fixme;
		}

		return \Pressbooks\HtmLawed::filter( $html, $config );
	}


	/**
	 * Create a temporary directory
	 *
	 * @throws \Exception
	 */
	protected function deleteTmpDir() {

		// Cleanup temporary directory, if any
		if ( ! empty( $this->tmpDir ) ) {
			$this->obliterateDir( $this->tmpDir );
		}
	}


	/**
	 * Zip the contents of an EPUB following the conventions outlined in Open Publication Structure 2.0.1
	 *
	 * @param $filename
	 *
	 * @return bool
	 */
	protected function zipEpub( $filename ) {

		$zip = new \PclZip( $filename );

		// Open Publication Structure 2.0.1
		// mimetype must be uncompressed, unencrypted, and the first file in the ZIP archive
		$list = $zip->create( $this->tmpDir . '/mimetype', PCLZIP_OPT_NO_COMPRESSION, PCLZIP_OPT_REMOVE_ALL_PATH );
		if ( 0 === absint( $list ) ) {
			return false;
		}

		$files = [];
		foreach ( new \RecursiveIteratorIterator( new \RecursiveDirectoryIterator( $this->tmpDir ) ) as $file ) {
			if ( ! $file->isFile() ) {
				continue;
			}
			if ( 'mimetype' === $file->getFilename() ) {
				continue;
			}
			$files[] = $file->getPathname();
		}

		$list = $zip->add( $files, '', $this->tmpDir );
		if ( 0 === absint( $list ) ) {
			return false;
		}

		return true;
	}


	/**
	 * Create Open Publication Structure 2.0.1 container.
	 */
	protected function createContainer() {

		file_put_contents(
			$this->tmpDir . '/mimetype',
			utf8_decode( 'application/epub+zip' )
		);

		mkdir( $this->tmpDir . '/META-INF' );
		mkdir( $this->tmpDir . '/OEBPS' );
		mkdir( $this->tmpDir . '/OEBPS/assets' );

		file_put_contents(
			$this->tmpDir . '/META-INF/container.xml',
			$this->loadTemplate( $this->dir . '/templates/epub201/container.php' )
		);

		file_put_contents(
			$this->tmpDir . '/META-INF/com.apple.ibooks.display-options.xml',
			$this->loadTemplate( $this->dir . '/templates/epub201/ibooks.php' )
		);

	}


	/**
	 * Create OEBPS/* files.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createOEPBS( $book_contents, $metadata ) {

		// First, setup and affect $this->stylesheet
		$this->createStylesheet();

		// Reset manifest
		$this->manifest = [];

		/* Note: order affects $this->manifest */

		// Cover
		$this->createCover( $book_contents, $metadata );

		// Before Title Page
		$this->createBeforeTitle( $book_contents, $metadata );

		// Title
		$this->createTitle( $book_contents, $metadata );

		// Copyright
		$this->createCopyright( $book_contents, $metadata );

		// Dedication and Epigraph (In that order!)
		$this->createDedicationAndEpigraph( $book_contents, $metadata );

		// Front-matter
		$this->createFrontMatter( $book_contents, $metadata );

		// Promo
		$this->createPromo( $book_contents, $metadata );

		// Parts, Chapters
		$this->createPartsAndChapters( $book_contents, $metadata );

		// Back-matter
		$this->createBackMatter( $book_contents, $metadata );

		// Table of contents
		// IMPORTANT: Do this last! Uses $this->manifest to generate itself
		$this->createToc( $book_contents, $metadata );
	}


	/**
	 * Create stylesheet. Change $this->stylesheet to a filename used by subsequent methods.
	 */
	protected function createStylesheet() {

		$this->stylesheet = strtolower( sanitize_file_name( wp_get_theme() . '.css' ) );
		$path_to_tmp_stylesheet = $this->tmpDir . "/OEBPS/{$this->stylesheet}";

		// Copy stylesheet
		file_put_contents(
			$path_to_tmp_stylesheet,
			$this->loadTemplate( $this->exportStylePath )
		);

		$this->scrapeKneadAndSaveCss( $this->exportStylePath, $path_to_tmp_stylesheet );
	}


	/**
	 * Parse CSS, copy assets, rewrite copy.
	 *
	 * @param string $path_to_original_stylesheet *
	 * @param string $path_to_copy_of_stylesheet
	 */
	protected function scrapeKneadAndSaveCss( $path_to_original_stylesheet, $path_to_copy_of_stylesheet ) {

		$sass = Container::get( 'Sass' );
		$scss_dir = pathinfo( $path_to_original_stylesheet, PATHINFO_DIRNAME );
		$path_to_epub_assets = $this->tmpDir . '/OEBPS/assets';

		$scss = file_get_contents( $path_to_copy_of_stylesheet );

		if ( $this->extraCss ) {
			$scss .= "\n" . $this->loadTemplate( $this->extraCss );
		}

		$scss = $sass->applyOverrides( $scss, $this->cssOverrides );

		if ( $sass->isCurrentThemeCompatible( 1 ) ) {
			$css = $sass->compile(
				$scss, [
				$sass->pathToUserGeneratedSass(),
				$sass->pathToPartials(),
				$sass->pathToFonts(),
				get_stylesheet_directory(),
				]
			);
		} elseif ( $sass->isCurrentThemeCompatible( 2 ) ) {
			$css = $sass->compile( $scss, $sass->defaultIncludePaths( 'epub' ) );
		} else {
			$css = static::injectHouseStyles( $scss );
		}

		// Search for all possible permutations of CSS url syntax: url("*"), url('*'), and url(*)
		$url_regex = '/url\(([\s])?([\"|\'])?(.*?)([\"|\'])?([\s])?\)/i';
		$css = preg_replace_callback(
			$url_regex, function ( $matches ) use ( $scss_dir, $path_to_epub_assets ) {

				$typography_dir = get_theme_root( 'pressbooks-book' ) . '/pressbooks-book/assets/book/typography/';

				$url = $matches[3];
				$filename = sanitize_file_name( basename( $url ) );

				if ( preg_match( '#^images/#', $url ) && substr_count( $url, '/' ) === 1 ) {

					// Look for "^images/"
					// Count 1 slash so that we don't touch stuff like "^images/out/of/bounds/"	or "^images/../../denied/"

					$my_image = realpath( "$scss_dir/$url" );
					if ( $my_image ) {
						copy( $my_image, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^../../images/epub/#', $url ) && substr_count( $url, '/' ) === 4 ) {

					// Look for "^../../images/epub/"
					// Count 4 slashes so that we explicitly select the path to the new assets directory

					$my_image = realpath( "$scss_dir/$url" );
					if ( $my_image ) {
						copy( $my_image, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^https?://#i', $url ) && preg_match( '/(' . $this->supportedImageExtensions . ')$/i', $url ) ) {

					// Look for images via http(s), pull them in locally

					$new_filename = $this->fetchAndSaveUniqueImage( $url, $path_to_epub_assets );
					if ( $new_filename ) {
						return "url(assets/$new_filename)";
					}
				} elseif ( preg_match( '#^themes-book/pressbooks-book/fonts/[a-zA-Z0-9_-]+(' . $this->supportedFontExtensions . ')$#i', $url ) ) {

					// Update themes-book/pressbooks-book/fonts/*.ttf (or .otf) path to new location, copy into our Epub
					$url = str_replace( 'themes-book/pressbooks-book/', $typography_dir, $url );
					$my_font = realpath( $url );

					if ( $my_font ) {
						copy( $my_font, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^fonts/[a-zA-Z0-9_-]+(' . $this->supportedFontExtensions . ')$#i', $url ) ) {

					// Look for wp-content/themes/pressbooks-book/assets/typography/fonts/*.ttf (or .otf), copy into our Epub

					$my_font = realpath( $typography_dir . $url );
					if ( $my_font ) {
						copy( $my_font, "$path_to_epub_assets/$filename" );
						return "url(assets/$filename)";
					}
				} elseif ( preg_match( '#^https?://#i', $url ) && preg_match( '/(' . $this->supportedFontExtensions . ')$/i', $url ) ) {

					// Look for fonts via http(s), pull them in locally

					$new_filename = $this->fetchAndSaveUniqueFont( $url, $path_to_epub_assets );
					if ( $new_filename ) {
						return "url(assets/$new_filename)";
					}
				}

				return $matches[0]; // No change

			}, $css
		);

		// Overwrite the new file with new info
		file_put_contents( $path_to_copy_of_stylesheet, $css );

		if ( WP_DEBUG ) {
			Container::get( 'Sass' )->debug( $css, $scss, 'epub' );
		}

	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createCover( $book_contents, $metadata ) {

		// Resize Image

		if ( ! empty( $metadata['pb_cover_image'] ) && ! \Pressbooks\Image\is_default_cover( $metadata['pb_cover_image'] ) ) {
			$source_path = \Pressbooks\Utility\get_media_path( $metadata['pb_cover_image'] );
		} else {
			$source_path = \Pressbooks\Image\default_cover_path();
		}
		$dest_image = sanitize_file_name( basename( $source_path ) );
		$dest_image = Sanitize\force_ascii( $dest_image );
		$dest_path = $this->tmpDir . '/OEBPS/assets/' . $dest_image;

		$img = wp_get_image_editor( $source_path );
		if ( ! is_wp_error( $img ) ) {
			// Take the longest dimension of the image and resize.
			// Cropping is turned off. The aspect ratio is maintained.
			$img->resize( 1563, 2500, false );
			$img->save( $dest_path );
			$this->coverImage = $dest_image;
		}

		// HTML

		$html = '<div id="cover-image">';
		if ( $this->coverImage ) {
			$html .= sprintf( '<img src="assets/%s" alt="%s" />', $this->coverImage, get_bloginfo( 'name' ) );
		}
		$html .= "</div>\n";

		// Create file, insert into manifest

		$vars = [
			'post_title' => __( 'Cover', 'pressbooks' ),
			'stylesheet' => $this->stylesheet,
			'post_content' => $html,
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$file_id = 'front-cover';
		$filename = "{$file_id}.{$this->filext}";

		file_put_contents(
			$this->tmpDir . "/OEBPS/$filename",
			$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
		);

		$this->manifest[ $file_id ] = [
			'ID' => -1,
			'post_title' => $vars['post_title'],
			'filename' => $filename,
		];

	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createBeforeTitle( $book_contents, $metadata ) {

		$front_matter_printf = '<div class="front-matter %s" id="%s">';
		$front_matter_printf .= '<div class="front-matter-title-wrap"><h3 class="front-matter-number">%s</h3><h1 class="front-matter-title">%s</h1></div>';
		$front_matter_printf .= '<div class="ugc front-matter-ugc">%s</div>%s';
		$front_matter_printf .= '</div>';

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$i = $this->frontMatterPos;
		foreach ( [ 'before-title' ] as $compare ) {
			foreach ( $book_contents['front-matter'] as $front_matter ) {

				if ( ! $front_matter['export'] ) {
					continue; // Skip
				}

				$front_matter_id = $front_matter['ID'];
				$subclass = \Pressbooks\Taxonomy::getFrontMatterType( $front_matter_id );

				if ( $compare !== $subclass ) {
					continue; //Skip
				}

				$slug = $front_matter['post_name'];
				$title = ( get_post_meta( $front_matter_id, 'pb_show_title', true ) ? $front_matter['post_title'] : '' );
				$content = $this->kneadHtml( $front_matter['post_content'], 'front-matter', $i );

				$vars['post_title'] = $front_matter['post_title'];
				$vars['post_content'] = sprintf(
					$front_matter_printf,
					$subclass,
					$slug,
					$i,
					Sanitize\decode( $title ),
					$content,
					''
				);

				$file_id = 'front-matter-' . sprintf( '%03s', $i );
				$filename = "{$file_id}-{$slug}.{$this->filext}";

				file_put_contents(
					$this->tmpDir . "/OEBPS/$filename",
					$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
				);

				$this->manifest[ $file_id ] = [
					'ID' => $front_matter['ID'],
					'post_title' => $front_matter['post_title'],
					'filename' => $filename,
				];

				++$i;
			}
		}
		$this->frontMatterPos = $i;
	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createTitle( $book_contents, $metadata ) {

		// Look for custom title-page

		$content = '';
		foreach ( $book_contents['front-matter'] as $front_matter ) {

			if ( ! $front_matter['export'] ) {
				continue; // Skip
			}

			$front_matter_id = $front_matter['ID'];
			$subclass = \Pressbooks\Taxonomy::getFrontMatterType( $front_matter_id );

			if ( 'title-page' !== $subclass ) {
				continue; // Skip
			}

			$content = $front_matter['post_content'];
			break;
		}

		// HTML

		$html = '<div id="title-page">';
		if ( $content ) {
			$html .= $content;
		} else {
			$html .= sprintf( '<h1 class="title">%s</h1>', get_bloginfo( 'name' ) );
			$html .= sprintf( '<h2 class="subtitle">%s</h2>', ( isset( $metadata['pb_subtitle'] ) ) ? $metadata['pb_subtitle'] : '' );
			$html .= sprintf( '<h3 class="author">%s</h3>', ( isset( $metadata['pb_author'] ) ) ? $metadata['pb_author'] : '' );
			$html .= sprintf( '<h4 class="author">%s</h4>', ( isset( $metadata['pb_contributing_authors'] ) ) ? $metadata['pb_contributing_authors'] : '' );
			if ( current_theme_supports( 'pressbooks_publisher_logo' ) ) {
				$html .= sprintf( '<div class="publisher-logo"><img src="%s" alt="%s" /></div>', get_theme_support( 'pressbooks_publisher_logo' )[0]['logo_uri'], __( 'Publisher Logo', 'pressbooks' ) ); // TODO: Support custom publisher logo.
			}
			$html .= sprintf( '<h4 class="publisher">%s</h4>', ( isset( $metadata['pb_publisher'] ) ) ? $metadata['pb_publisher'] : '' );
			$html .= sprintf( '<h5 class="publisher-city">%s</h5>', ( isset( $metadata['pb_publisher_city'] ) ) ? $metadata['pb_publisher_city'] : '' );
		}
		$html .= "</div>\n";

		// Create file, insert into manifest

		$vars = [
			'post_title' => __( 'Title Page', 'pressbooks' ),
			'stylesheet' => $this->stylesheet,
			'post_content' => $this->kneadHtml( $html, 'custom' ),
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$file_id = 'title-page';
		$filename = "{$file_id}.{$this->filext}";

		file_put_contents(
			$this->tmpDir . "/OEBPS/$filename",
			$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
		);

		$this->manifest[ $file_id ] = [
			'ID' => -1,
			'post_title' => $vars['post_title'],
			'filename' => $filename,
		];

	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createCopyright( $book_contents, $metadata ) {

		// HTML
		$html = '<div id="copyright-page"><div class="ugc">';

		// Custom copyright
		if ( ! empty( $metadata['pb_custom_copyright'] ) ) {
			$html .= $this->kneadHtml( $this->tidy( $metadata['pb_custom_copyright'] ), 'custom' );
		}

		// License
		$license = $this->doCopyrightLicense( $metadata );
		if ( $license ) {
			$html .= $this->kneadHtml( $this->tidy( $license ), 'custom' );
		}

		// default, so something is displayed
		if ( empty( $metadata['pb_custom_copyright'] ) && empty( $license ) ) {
			$html .= '<p>';
			$html .= get_bloginfo( 'name' ) . ' ' . __( 'Copyright', 'pressbooks' ) . ' &#169; ';
			if ( ! empty( $meta['pb_copyright_year'] ) ) {
				$html .= $meta['pb_copyright_year'];
			} elseif ( ! empty( $meta['pb_publication_date'] ) ) {
				$html .= strftime( '%Y', $meta['pb_publication_date'] );
			} else {
				$html .= date( 'Y' );
			}
			if ( ! empty( $metadata['pb_copyright_holder'] ) ) {
				$html .= ' ' . __( 'by', 'pressbooks' ) . ' ' . $metadata['pb_copyright_holder'] . '. ';
			}
			$html .= '</p>';
		}

		// Copyright
		// Please be kind, help Pressbooks grow by leaving this on!
		if ( empty( $GLOBALS['PB_SECRET_SAUCE']['TURN_OFF_FREEBIE_NOTICES_EPUB'] ) ) {
			$freebie_notice = 'This book was produced using <a href="http://pressbooks.com/">Pressbooks.com</a>.';
			$html .= "<p>$freebie_notice</p>";
		}

		$html .= "</div></div>\n";

		// Create file, insert into manifest

		$vars = [
			'post_title' => __( 'Copyright', 'pressbooks' ),
			'stylesheet' => $this->stylesheet,
			'post_content' => $html,
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$file_id = 'copyright';
		$filename = "{$file_id}.{$this->filext}";

		file_put_contents(
			$this->tmpDir . "/OEBPS/$filename",
			$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
		);

		$this->manifest[ $file_id ] = [
			'ID' => -1,
			'post_title' => $vars['post_title'],
			'filename' => $filename,
		];

	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createDedicationAndEpigraph( $book_contents, $metadata ) {

		$front_matter_printf = '<div class="front-matter %s" id="%s">';
		$front_matter_printf .= '<div class="front-matter-title-wrap"><h3 class="front-matter-number">%s</h3><h1 class="front-matter-title">%s</h1></div>';
		$front_matter_printf .= '<div class="ugc front-matter-ugc">%s</div>%s';
		$front_matter_printf .= '</div>';

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$i = $this->frontMatterPos;
		$last_pos = false;
		foreach ( [ 'dedication', 'epigraph' ] as $compare ) {
			foreach ( $book_contents['front-matter'] as $front_matter ) {

				if ( ! $front_matter['export'] ) {
					continue; // Skip
				}

				$front_matter_id = $front_matter['ID'];
				$subclass = \Pressbooks\Taxonomy::getFrontMatterType( $front_matter_id );

				if ( $compare !== $subclass ) {
					continue; //Skip
				}

				$slug = $front_matter['post_name'];
				$title = ( get_post_meta( $front_matter_id, 'pb_show_title', true ) ? $front_matter['post_title'] : '' );
				$content = $this->kneadHtml( $front_matter['post_content'], 'front-matter', $i );

				$vars['post_title'] = $front_matter['post_title'];
				$vars['post_content'] = sprintf(
					$front_matter_printf,
					$subclass,
					$slug,
					$i,
					Sanitize\decode( $title ),
					$content,
					''
				);

				$file_id = 'front-matter-' . sprintf( '%03s', $i );
				$filename = "{$file_id}-{$slug}.{$this->filext}";

				file_put_contents(
					$this->tmpDir . "/OEBPS/$filename",
					$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
				);

				$this->manifest[ $file_id ] = [
					'ID' => $front_matter['ID'],
					'post_title' => $front_matter['post_title'],
					'filename' => $filename,
				];

				++$i;
				$last_pos = $i;
			}
		}
		$this->frontMatterPos = $i;
		if ( $last_pos ) {
			$this->frontMatterLastPos = $last_pos - 1;
		}
	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createFrontMatter( $book_contents, $metadata ) {

		$front_matter_printf = '<div class="front-matter %s" id="%s">';
		$front_matter_printf .= '<div class="front-matter-title-wrap"><h3 class="front-matter-number">%s</h3><h1 class="front-matter-title">%s</h1></div>';
		$front_matter_printf .= '<div class="ugc front-matter-ugc">%s</div>%s';
		$front_matter_printf .= '</div>';

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'append_front_matter_content' => '',
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$i = $this->frontMatterPos;
		foreach ( $book_contents['front-matter'] as $front_matter ) {

			if ( ! $front_matter['export'] ) {
				continue; // Skip
			}

			$front_matter_id = $front_matter['ID'];
			$subclass = \Pressbooks\Taxonomy::getFrontMatterType( $front_matter_id );

			if ( 'dedication' === $subclass || 'epigraph' === $subclass || 'title-page' === $subclass || 'before-title' === $subclass ) {
				continue; // Skip
			}

			if ( 'introduction' === $subclass ) {
				$this->hasIntroduction = true;
			}

			$slug = $front_matter['post_name'];
			$title = ( get_post_meta( $front_matter_id, 'pb_show_title', true ) ? $front_matter['post_title'] : '' );
			$content = $this->kneadHtml( $front_matter['post_content'], 'front-matter', $i );
			$append_front_matter_content = $this->kneadHtml( apply_filters( 'pb_append_front_matter_content', '', $front_matter_id ), 'front-matter' );
			$short_title = trim( get_post_meta( $front_matter_id, 'pb_short_title', true ) );
			$subtitle = trim( get_post_meta( $front_matter_id, 'pb_subtitle', true ) );
			$author = trim( get_post_meta( $front_matter_id, 'pb_section_author', true ) );

			if ( \Pressbooks\Modules\Export\Export::isParsingSubsections() === true ) {
				$sections = \Pressbooks\Book::getSubsections( $front_matter_id );

				if ( $sections ) {
					$content = \Pressbooks\Book::tagSubsections( $content, $front_matter_id );
				}
			}

			if ( $author ) {
				$content = '<h2 class="chapter-author">' . Sanitize\decode( $author ) . '</h2>' . $content;
			}

			if ( $subtitle ) {
				$content = '<h2 class="chapter-subtitle">' . Sanitize\decode( $subtitle ) . '</h2>' . $content;
			}

			if ( $short_title ) {
				$content = '<h6 class="short-title">' . Sanitize\decode( $short_title ) . '</h6>' . $content;
			}

			$append_front_matter_content .= $this->doSectionLevelLicense( $metadata, $front_matter_id );

			$vars['post_title'] = $front_matter['post_title'];
			$vars['post_content'] = sprintf(
				$front_matter_printf,
				$subclass,
				$slug,
				$i,
				Sanitize\decode( $title ),
				$content,
				$var['append_front_matter_content'] = $append_front_matter_content,
				''
			);

			$file_id = 'front-matter-' . sprintf( '%03s', $i );
			$filename = "{$file_id}-{$slug}.{$this->filext}";

			file_put_contents(
				$this->tmpDir . "/OEBPS/$filename",
				$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
			);

			$this->manifest[ $file_id ] = [
				'ID' => $front_matter['ID'],
				'post_title' => $front_matter['post_title'],
				'filename' => $filename,
			];

			++$i;
		}

		$this->frontMatterPos = $i;
	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createPromo( $book_contents, $metadata ) {

		$promo_html = apply_filters( 'pressbooks_epub_promo', '' );
		if ( $promo_html ) {

			$file_id = 'pressbooks-promo';
			$filename = "{$file_id}.{$this->filext}";

			$vars = [
				'post_title' => __( 'Make your own books using Pressbooks.com', 'pressbooks' ),
				'stylesheet' => $this->stylesheet,
				'post_content' => $this->kneadHtml( $promo_html, 'custom' ),
				'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
				'lang' => $this->lang,
			];

			file_put_contents(
				$this->tmpDir . "/OEBPS/$filename",
				$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
			);

			$this->manifest[ $file_id ] = [
				'ID' => -1,
				'post_title' => $vars['post_title'],
				'filename' => $filename,
			];
		}
	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createPartsAndChapters( $book_contents, $metadata ) {

		$part_printf = '<div class="part %s" id="%s">';
		$part_printf .= '<div class="part-title-wrap"><h3 class="part-number">%s</h3><h1 class="part-title">%s</h1></div>%s';
		$part_printf .= '</div>';

		$chapter_printf = '<div class="chapter %s" id="%s">';
		$chapter_printf .= '<div class="chapter-title-wrap"><h3 class="chapter-number">%s</h3><h2 class="chapter-title">%s</h2></div>';
		$chapter_printf .= '<div class="ugc chapter-ugc">%s</div>%s';
		$chapter_printf .= '</div>';

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'append_chapter_content' => '',
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		// Parts, Chapters
		$i = $j = $c = $p = 1;
		foreach ( $book_contents['part'] as $part ) {

			$invisibility = ( get_post_meta( $part['ID'], 'pb_part_invisible', true ) === 'on' ) ? 'invisible' : '';

			$part_printf_changed = '';
			$array_pos = count( $this->manifest );
			$has_chapters = false;

			// Inject introduction class?
			if ( ! $this->hasIntroduction && count( $book_contents['part'] ) > 1 ) {
				$part_printf_changed = str_replace( '<div class="part %s" id=', '<div class="part introduction %s" id=', $part_printf );
				$this->hasIntroduction = true;
			}

			// Inject part content?
			$part_content = trim( $part['post_content'] );
			if ( $part_content ) {
				$part_content = $this->kneadHtml( $this->preProcessPostContent( $part_content ), 'custom', $p );
				$part_printf_changed = str_replace( '</h1></div>%s</div>', '</h1></div><div class="ugc part-ugc">%s</div></div>', $part_printf );
			}

			foreach ( $part['chapters'] as $chapter ) {

				if ( ! $chapter['export'] ) {
					continue; // Skip
				}

				$chapter_printf_changed = '';
				$chapter_id = $chapter['ID'];
				$subclass = \Pressbooks\Taxonomy::getChapterType( $chapter_id );
				$slug = $chapter['post_name'];
				$title = ( get_post_meta( $chapter_id, 'pb_show_title', true ) ? $chapter['post_title'] : '' );
				$content = $this->kneadHtml( $chapter['post_content'], 'chapter', $j );
				$append_chapter_content = $this->kneadHtml( apply_filters( 'pb_append_chapter_content', '', $chapter_id ), 'chapter' );
				$short_title = false; // Ie. running header title is not used in EPUB
				$subtitle = trim( get_post_meta( $chapter_id, 'pb_subtitle', true ) );
				$author = trim( get_post_meta( $chapter_id, 'pb_section_author', true ) );

				if ( \Pressbooks\Modules\Export\Export::isParsingSubsections() === true ) {
					$sections = \Pressbooks\Book::getSubsections( $chapter_id );

					if ( $sections ) {
						$content = \Pressbooks\Book::tagSubsections( $content, $chapter_id );
					}
				}

				if ( $author ) {
					$content = '<h2 class="chapter-author">' . Sanitize\decode( $author ) . '</h2>' . $content;
				}

				if ( $subtitle ) {
					$content = '<h2 class="chapter-subtitle">' . Sanitize\decode( $subtitle ) . '</h2>' . $content;
				}

				if ( $short_title ) {
					$content = '<h6 class="short-title">' . Sanitize\decode( $short_title ) . '</h6>' . $content;
				}

				// Inject introduction class?
				if ( ! $this->hasIntroduction ) {
					$chapter_printf_changed = str_replace( '<div class="chapter %s" id=', '<div class="chapter introduction %s" id=', $chapter_printf );
					$this->hasIntroduction = true;
				}

				$append_chapter_content .= $this->doSectionLevelLicense( $metadata, $chapter_id );

				$n = ( 'numberless' === $subclass ) ? '' : $c;
				$vars['post_title'] = $chapter['post_title'];
				$vars['post_content'] = sprintf(
					( $chapter_printf_changed ? $chapter_printf_changed : $chapter_printf ),
					$subclass,
					$slug,
					( $this->numbered ? $n : '' ),
					Sanitize\decode( $title ),
					$content,
					$var['append_chapter_content'] = $append_chapter_content,
					''
				);

				$file_id = 'chapter-' . sprintf( '%03s', $j );
				$filename = "{$file_id}-{$slug}.{$this->filext}";

				file_put_contents(
					$this->tmpDir . "/OEBPS/$filename",
					$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
				);

				$this->manifest[ $file_id ] = [
					'ID' => $chapter['ID'],
					'post_title' => $chapter['post_title'],
					'filename' => $filename,
				];

				$has_chapters = true;

				$j++;

				if ( 'numberless' !== $subclass ) {
					++$c;
				}
			}

			if ( count( $book_contents['part'] ) === 1 && $part_content ) { // only part, has content
				$slug = $part['post_name'];
				$m = ( 'invisible' === $invisibility ) ? '' : $p;
				$vars['post_title'] = $part['post_title'];
				$vars['post_content'] = sprintf(
					( $part_printf_changed ? $part_printf_changed : $part_printf ),
					$invisibility,
					$slug,
					( $this->numbered ? \Pressbooks\L10n\romanize( $m ) : '' ),
					Sanitize\decode( $part['post_title'] ),
					$part_content
				);

				$file_id = 'part-' . sprintf( '%03s', $i );
				$filename = "{$file_id}-{$slug}.{$this->filext}";

				file_put_contents(
					$this->tmpDir . "/OEBPS/$filename",
					$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
				);

				// Insert into correct pos
				$this->manifest = array_slice( $this->manifest, 0, $array_pos, true ) + [
						$file_id => [
							'ID' => $part['ID'],
							'post_title' => $part['post_title'],
							'filename' => $filename,
						],
					] + array_slice( $this->manifest, $array_pos, count( $this->manifest ) - 1, true );

				++$i;
				if ( 'invisible' !== $invisibility ) {
					++$p;
				}
			} elseif ( count( $book_contents['part'] ) > 1 ) { // multiple parts
				if ( $has_chapters ) { // has chapter
					$slug = $part['post_name'];
					$m = ( 'invisible' === $invisibility ) ? '' : $p;
					$vars['post_title'] = $part['post_title'];
					$vars['post_content'] = sprintf(
						( $part_printf_changed ? $part_printf_changed : $part_printf ),
						$invisibility,
						$slug,
						( $this->numbered ? \Pressbooks\L10n\romanize( $m ) : '' ),
						Sanitize\decode( $part['post_title'] ),
						$part_content
					);

					$file_id = 'part-' . sprintf( '%03s', $i );
					$filename = "{$file_id}-{$slug}.{$this->filext}";

					file_put_contents(
						$this->tmpDir . "/OEBPS/$filename",
						$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
					);

					// Insert into correct pos
					$this->manifest = array_slice( $this->manifest, 0, $array_pos, true ) + [
							$file_id => [
								'ID' => $part['ID'],
								'post_title' => $part['post_title'],
								'filename' => $filename,
							],
						] + array_slice( $this->manifest, $array_pos, count( $this->manifest ) - 1, true );

					++$i;
					if ( 'invisible' !== $invisibility ) {
						++$p;
					}
				} else { // no chapter
					if ( $part_content ) { // has content
						$slug = $part['post_name'];
						$m = ( 'invisible' === $invisibility ) ? '' : $p;
						$vars['post_title'] = $part['post_title'];
						$vars['post_content'] = sprintf(
							( $part_printf_changed ? $part_printf_changed : $part_printf ),
							$invisibility,
							$slug,
							( $this->numbered ? \Pressbooks\L10n\romanize( $m ) : '' ),
							Sanitize\decode( $part['post_title'] ),
							$part_content
						);

						$file_id = 'part-' . sprintf( '%03s', $i );
						$filename = "{$file_id}-{$slug}.{$this->filext}";

						file_put_contents(
							$this->tmpDir . "/OEBPS/$filename",
							$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
						);

						// Insert into correct pos
						$this->manifest = array_slice( $this->manifest, 0, $array_pos, true ) + [
								$file_id => [
									'ID' => $part['ID'],
									'post_title' => $part['post_title'],
									'filename' => $filename,
								],
							] + array_slice( $this->manifest, $array_pos, count( $this->manifest ) - 1, true );

						++$i;
						if ( 'invisible' !== $invisibility ) {
							++$p;
						}
					}
				}
			}

			// Did we actually inject the introduction class?
			if ( $part_printf_changed && ! $has_chapters ) {
				$this->hasIntroduction = false;
			}
		}
	}


	/**
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createBackMatter( $book_contents, $metadata ) {

		$back_matter_printf = '<div class="back-matter %s" id="%s">';
		$back_matter_printf .= '<div class="back-matter-title-wrap"><h3 class="back-matter-number">%s</h3><h1 class="back-matter-title">%s</h1></div>';
		$back_matter_printf .= '<div class="ugc back-matter-ugc">%s</div>%s';
		$back_matter_printf .= '</div>';

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'append_back_matter_content' => '',
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		$i = 1;
		foreach ( $book_contents['back-matter'] as $back_matter ) {

			if ( ! $back_matter['export'] ) {
				continue; // Skip
			}

			$back_matter_id = $back_matter['ID'];
			$subclass = \Pressbooks\Taxonomy::getBackMatterType( $back_matter_id );
			$slug = $back_matter['post_name'];
			$title = ( get_post_meta( $back_matter_id, 'pb_show_title', true ) ? $back_matter['post_title'] : '' );
			$content = $this->kneadHtml( $back_matter['post_content'], 'back-matter', $i );
			$append_back_matter_content = $this->kneadHtml( apply_filters( 'pb_append_back_matter_content', '', $back_matter_id ), 'back-matter' );
			$short_title = trim( get_post_meta( $back_matter_id, 'pb_short_title', true ) );
			$subtitle = trim( get_post_meta( $back_matter_id, 'pb_subtitle', true ) );
			$author = trim( get_post_meta( $back_matter_id, 'pb_section_author', true ) );

			if ( \Pressbooks\Modules\Export\Export::isParsingSubsections() === true ) {
				$sections = \Pressbooks\Book::getSubsections( $back_matter_id );

				if ( $sections ) {
					$content = \Pressbooks\Book::tagSubsections( $content, $back_matter_id );
				}
			}

			if ( $author ) {
				$content = '<h2 class="chapter-author">' . Sanitize\decode( $author ) . '</h2>' . $content;
			}

			if ( $subtitle ) {
				$content = '<h2 class="chapter-subtitle">' . Sanitize\decode( $subtitle ) . '</h2>' . $content;
			}

			if ( $short_title ) {
				$content = '<h6 class="short-title">' . Sanitize\decode( $short_title ) . '</h6>' . $content;
			}

			$append_back_matter_content .= $this->doSectionLevelLicense( $metadata, $back_matter_id );

			$vars['post_title'] = $back_matter['post_title'];
			$vars['post_content'] = sprintf(
				$back_matter_printf,
				$subclass,
				$slug,
				$i,
				Sanitize\decode( $title ),
				$content,
				$var['append_back_matter_content'] = $append_back_matter_content,
				''
			);

			$file_id = 'back-matter-' . sprintf( '%03s', $i );
			$filename = "{$file_id}-{$slug}.{$this->filext}";

			file_put_contents(
				$this->tmpDir . "/OEBPS/$filename",
				$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
			);

			$this->manifest[ $file_id ] = [
				'ID' => $back_matter['ID'],
				'post_title' => $back_matter['post_title'],
				'filename' => $filename,
			];

			++$i;
		}

	}


	/**
	 * Uses $this->manifest to generate itself.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 */
	protected function createToc( $book_contents, $metadata ) {

		$vars = [
			'post_title' => '',
			'stylesheet' => $this->stylesheet,
			'post_content' => '',
			'isbn' => ( isset( $metadata['pb_ebook_isbn'] ) ) ? $metadata['pb_ebook_isbn'] : '',
			'lang' => $this->lang,
		];

		// Start by inserting self into correct manifest position
		$array_pos = $this->positionOfToc();

		$file_id = 'table-of-contents';
		$filename = "{$file_id}.{$this->filext}";
		$vars['post_title'] = __( 'Table Of Contents', 'pressbooks' );

		$this->manifest = array_slice( $this->manifest, 0, $array_pos + 1, true ) + [
				$file_id => [
					'ID' => -1,
					'post_title' => $vars['post_title'],
					'filename' => $filename,
				],
			] + array_slice( $this->manifest, $array_pos + 1, count( $this->manifest ) - 1, true );

		// HTML

		$li_count = 0;
		$i = 1; // Chapter count
		$m = 1; // Part count
		$html = '<div id="toc"><h1>' . __( 'Contents', 'pressbooks' ) . '</h1><ul>';
		foreach ( $this->manifest as $k => $v ) {

			// We only care about front-matter, part, chapter, back-matter
			// Skip the rest

			$subtitle = '';
			$author = '';
			$license = '';
			$title = Sanitize\strip_br( $v['post_title'] );
			if ( preg_match( '/^front-matter-/', $k ) ) {
				$class = 'front-matter ';
				$class .= \Pressbooks\Taxonomy::getFrontMatterType( $v['ID'] );
				$subtitle = trim( get_post_meta( $v['ID'], 'pb_subtitle', true ) );
				$author = trim( get_post_meta( $v['ID'], 'pb_section_author', true ) );
				$license = $this->doTocLicense( $v['ID'] );
			} elseif ( preg_match( '/^part-/', $k ) ) {
				$class = 'part';
				if ( get_post_meta( $v['ID'], 'pb_part_invisible', true ) === 'on' ) {
					$class .= ' display-none';
				} else {
					$title = ( $this->numbered ? __( 'Part', 'pressbooks' ) . ' ' . \Pressbooks\L10n\romanize( $m ) . '. ' : '' ) . $title;
					$m++;
				}
			} elseif ( preg_match( '/^chapter-/', $k ) ) {
				$class = 'chapter';
				$class .= \Pressbooks\Taxonomy::getChapterType( $v['ID'] );
				$subtitle = trim( get_post_meta( $v['ID'], 'pb_subtitle', true ) );
				$author = trim( get_post_meta( $v['ID'], 'pb_section_author', true ) );
				$license = $this->doTocLicense( $v['ID'] );
				if ( $this->numbered && \Pressbooks\Taxonomy::getChapterType( $v['ID'] ) !== 'numberless' ) {
					$title = " $i. " . $title;
				}
				if ( \Pressbooks\Taxonomy::getChapterType( $v['ID'] ) !== 'numberless' ) {
					++$i;
				}
			} elseif ( preg_match( '/^back-matter-/', $k ) ) {
				$class = 'back-matter ';
				$class .= \Pressbooks\Taxonomy::getBackMatterType( $v['ID'] );
				$subtitle = trim( get_post_meta( $v['ID'], 'pb_subtitle', true ) );
				$author = trim( get_post_meta( $v['ID'], 'pb_section_author', true ) );
				$license = $this->doTocLicense( $v['ID'] );
			} else {
				continue;
			}

			$html .= sprintf( '<li class="%s"><a href="%s"><span class="toc-chapter-title">%s</span>', $class, $v['filename'], Sanitize\decode( $title ) );

			if ( $subtitle ) {
				$html .= ' <span class="chapter-subtitle">' . Sanitize\decode( $subtitle ) . '</span>';
			}

			if ( $author ) {
				$html .= ' <span class="chapter-author">' . Sanitize\decode( $author ) . '</span>';
			}

			if ( $license ) {
				$html .= ' <span class="chapter-license">' . $license . '</span> ';
			}

			$html .= '</a>';

			if ( \Pressbooks\Modules\Export\Export::isParsingSubsections() === true ) {
				$sections = \Pressbooks\Book::getSubsections( $v['ID'] );
				if ( $sections ) {
					$html .= '<ul class="sections">';
					foreach ( $sections as $id => $title ) {
						$html .= '<li class="section"><a href="' . $v['filename'] . '#' . $id . '"><span class="toc-subsection-title">' . Sanitize\decode( $title ) . '</span></a></li>';
					}
					$html .= '</ul>';
				}
			}

			$html .= "</li>\n";
			++$li_count;

		}
		if ( 0 === $li_count ) {
			$html .= '<li></li>';
		}
		$html .= "</ul></div>\n";

		// Create file

		$vars['post_content'] = $html;

		file_put_contents(
			$this->tmpDir . "/OEBPS/$filename",
			$this->loadTemplate( $this->dir . '/templates/epub201/html.php', $vars )
		);

	}


	/**
	 * Determine position of TOC based on Chicago Manual Of Style.
	 *
	 * @return int
	 */
	protected function positionOfToc() {

		$search = array_keys( $this->manifest );

		if ( false === $this->frontMatterLastPos ) {

			$array_pos = array_search( 'copyright', $search, true );
			if ( false === $array_pos ) {
				$array_pos = -1;
			}
		} else {

			$array_pos = -1;
			$preg = '/^front-matter-' . sprintf( '%03s', $this->frontMatterLastPos ) . '$/';
			foreach ( $search as $key => $val ) {
				if ( preg_match( $preg, $val ) ) {
					$array_pos = $key;
					break;
				}
			}
		}

		return $array_pos;
	}


	/**
	 * Pummel the HTML into EPUB compatible dough.
	 *
	 * @param string $html
	 * @param string $type front-matter, part, chapter, back-matter, ...
	 * @param int $pos (optional) position of content, used when creating filenames like: chapter-001, chapter-002, ...
	 *
	 * @return string
	 */
	protected function kneadHtml( $html, $type, $pos = 0 ) {

		libxml_use_internal_errors( true );

		// Load HTML snippet into DOMDocument using UTF-8 hack
		$utf8_hack = '<?xml version="1.0" encoding="UTF-8"?>';
		$doc = new \DOMDocument();
		$doc->loadHTML( $utf8_hack . $html );

		// Download images, change to relative paths
		$doc = $this->scrapeAndKneadImages( $doc );

		// Download audio files, change to relative paths
		$doc = $this->scrapeAndKneadMedia( $doc );

		// Deal with <a href="">, <a href=''>, and other mutations
		$doc = $this->kneadHref( $doc, $type, $pos );

		// Make sure empty tags (e.g. <b></b>) don't get turned into self-closing versions by adding an empty text node to them.
		$xpath = new \DOMXPath( $doc );
		while ( ( $nodes = $xpath->query( '//*[not(text() or node() or self::br or self::hr or self::img)]' ) ) && $nodes->length > 0 ) {
			foreach ( $nodes as $node ) {
				/** @var \DOMElement $node */
				$node->appendChild( new \DOMText( '' ) );
			}
		}

		// Remove srcset attributes because responsive images aren't a thing in the EPUB world.
		$srcsets = $xpath->query( '//img[@srcset]' );
		foreach ( $srcsets as $srcset ) {
			/** @var \DOMElement $srcset */
			$srcset->removeAttribute( 'srcset' );
		}

		// If you are storing multi-byte characters in XML, then saving the XML using saveXML() will create problems.
		// Ie. It will spit out the characters converted in encoded format. Instead do the following:
		$html = $doc->saveXML( $doc->documentElement );

		// Remove auto-created <html> <body> and <!DOCTYPE> tags.
		$html = preg_replace( '/^<!DOCTYPE.+?>/', '', str_replace( [ '<html>', '</html>', '<body>', '</body>' ], [ '', '', '', '' ], $html ) );

		// Mobi7 hacks
		$html = $this->transformXML( $utf8_hack . "<html>$html</html>", $this->dir . '/templates/epub201/mobi-hacks.xsl' );

		$errors = libxml_get_errors(); // TODO: Handle errors gracefully
		libxml_clear_errors();

		return $html;
	}


	/**
	 * Parse HTML snippet, download all found <img> tags into /OEBPS/assets/, return the HTML with changed <img> paths.
	 *
	 * @param \DOMDocument $doc
	 *
	 * @return \DOMDocument
	 */
	protected function scrapeAndKneadImages( \DOMDocument $doc ) {

		$fullpath = $this->tmpDir . '/OEBPS/assets';

		$images = $doc->getElementsByTagName( 'img' );
		foreach ( $images as $image ) {
			/** @var \DOMElement $image */
			// Fetch image, change src
			$url = $image->getAttribute( 'src' );
			$filename = $this->fetchAndSaveUniqueImage( $url, $fullpath );
			if ( $filename ) {
				// Replace with new image
				$image->setAttribute( 'src', 'assets/' . $filename );
			} else {
				// Tag broken image
				$image->setAttribute( 'src', "{$url}#fixme" );
			}
		}

		return $doc;
	}


	/**
	 * Fetch an image with wp_remote_get(), save it to $fullpath with a unique name.
	 * Will return an empty string if something went wrong.
	 *
	 * @param $url string
	 * @param $fullpath string
	 *
	 * @return string filename
	 */
	protected function fetchAndSaveUniqueImage( $url, $fullpath ) {

		if ( isset( $this->fetchedImageCache[ $url ] ) ) {
			return $this->fetchedImageCache[ $url ];
		}

		$response = \Pressbooks\Utility\remote_get_retry( $url, [ 'timeout' => $this->timeout ] );

		// WordPress error?
		if ( is_wp_error( $response ) ) {
			try {
				// protocol relative urls handed to wp_remote_get will fail
				// try adding a protocol
				$protocol_relative = wp_parse_url( $url );
				if ( ! isset( $protocol_relative['scheme'] ) ) {
					if ( true === is_ssl() ) {
						$url = 'https:' . $url;
					} else {
						$url = 'http:' . $url;
					}
				}
				$response = wp_remote_get( $url, [ 'timeout' => $this->timeout ] );
				if ( is_wp_error( $response ) ) {
					throw new \Exception( 'Bad URL: ' . $url );
				}
			} catch ( \Exception $exc ) {
				$this->fetchedImageCache[ $url ] = '';
				error_log( '\PressBooks\Export\Epub201\fetchAndSaveUniqueImage wp_error on wp_remote_get() - ' . $response->get_error_message() . ' - ' . $exc->getMessage() );

				return '';
			}

		}

		// Basename without query string
		$filename = explode( '?', basename( $url ) );

		// isolate latex image service from WP, add file extension
		$host = parse_url( $url, PHP_URL_HOST );
		if ( ( str_ends_with( $host, 'wordpress.com' ) || str_ends_with( $host, 'wp.com' ) ) && 'latex.php' === $filename[0] ) {
			$filename = md5( array_pop( $filename ) );
			// content-type = 'image/png'
			$type = explode( '/', $response['headers']['content-type'] );
			$type = array_pop( $type );
			$filename = $filename . '.' . $type;
		} else {
			$filename = array_shift( $filename );
			$filename = sanitize_file_name( urldecode( $filename ) );
			$filename = Sanitize\force_ascii( $filename );
		}

		$tmp_file = \Pressbooks\Utility\create_tmp_file();
		file_put_contents( $tmp_file, wp_remote_retrieve_body( $response ) );

		if ( ! \Pressbooks\Image\is_valid_image( $tmp_file, $filename ) ) {
			$this->fetchedImageCache[ $url ] = '';
			error_log( '\PressBooks\Export\Epub201\fetchAndSaveUniqueImage is_valid_image, not a valid image ' );
			return ''; // Not an image
		}

		if ( $this->compressImages ) {
			$format = explode( '.', $filename );
			$format = strtolower( end( $format ) ); // Extension
			\Pressbooks\Image\resize_down( $format, $tmp_file );
		}

		// Check for duplicates, save accordingly
		if ( ! file_exists( "$fullpath/$filename" ) ) {
			copy( $tmp_file, "$fullpath/$filename" );
		} elseif ( md5( file_get_contents( $tmp_file ) ) !== md5( file_get_contents( "$fullpath/$filename" ) ) ) {
			$filename = wp_unique_filename( $fullpath, $filename );
			copy( $tmp_file, "$fullpath/$filename" );
		}

		$this->fetchedImageCache[ $url ] = $filename;
		return $filename;
	}


	/**
	 * Fetch a font with wp_remote_get(), save it to $fullpath with a unique name.
	 * Will return an empty string if something went wrong.
	 *
	 * @param $url string
	 * @param $fullpath string
	 *
	 * @return string filename
	 */
	protected function fetchAndSaveUniqueFont( $url, $fullpath ) {

		if ( isset( $this->fetchedFontCache[ $url ] ) ) {
			return $this->fetchedFontCache[ $url ];
		}

		$response = wp_remote_get( $url, [ 'timeout' => $this->timeout ] );

		// WordPress error?
		if ( is_wp_error( $response ) ) {
			// TODO: Properly handle errors returned via $response->get_error_message();
			$this->fetchedFontCache[ $url ] = '';
			return '';
		}

		// Basename without query string
		$filename = explode( '?', basename( $url ) );
		$filename = array_shift( $filename );

		$filename = sanitize_file_name( urldecode( $filename ) );
		$filename = Sanitize\force_ascii( $filename );

		$tmp_file = \Pressbooks\Utility\create_tmp_file();
		file_put_contents( $tmp_file, wp_remote_retrieve_body( $response ) );

		// TODO: Validate that this is actually a font
		// TODO: Refactor fetchAndSaveUniqueImage() and fetchAndSaveUniqueFont() into a single method, but "inject" different validation

		// Check for duplicates, save accordingly
		if ( ! file_exists( "$fullpath/$filename" ) ) {
			copy( $tmp_file, "$fullpath/$filename" );
		} elseif ( md5( file_get_contents( $tmp_file ) ) !== md5( file_get_contents( "$fullpath/$filename" ) ) ) {
			$filename = wp_unique_filename( $fullpath, $filename );
			copy( $tmp_file, "$fullpath/$filename" );
		}

		$this->fetchedFontCache[ $url ] = $filename;
		return $filename;
	}

	/**
	 * This is a stub for an Epub3 feature
	 * Do nothing
	 *
	 * @param \DOMDocument $doc
	 *
	 * @return \DOMDocument
	 */
	protected function scrapeAndKneadMedia( \DOMDocument $doc ) {
		return $doc;
	}

	/**
	 * Change hrefs
	 *
	 * @param \DOMDocument $doc
	 * @param string $type front-matter, part, chapter, back-matter, ...
	 * @param int $pos (optional) position of content, used when creating filenames like: chapter-001, chapter-002, ...
	 *
	 * @return \DOMDocument
	 */
	protected function kneadHref( \DOMDocument $doc, $type, $pos ) {

		$urls = $doc->getElementsByTagName( 'a' );
		foreach ( $urls as $url ) {
			/** @var \DOMElement $url */
			$current_url = '' . $url->getAttribute( 'href' ); // Stringify

			// Don't touch empty urls
			if ( ! trim( $current_url ) ) {
				continue;
			}

			// WordPress auto wraps images in a href tags.
			// For example: <a href="some_image-original.png"><img src="some_image-300x200.png" /></a>
			// This causes an EPUB validation error of: hyperlink to non-standard resource ( of type 'image/...' )
			// We fix this by removing the href
			if ( $url->childNodes->length ) {
				foreach ( $url->childNodes as $node ) {
					/** @var \DOMElement $node */
					if ( 'img' === $node->nodeName && $this->fuzzyImageNameMatch( $current_url, $node->getAttribute( 'src' ) ) ) {
						$url->removeAttribute( 'href' );
						continue 2;
					}
				}
			}

			// Determine if we are trying to link to our own internal content
			$internal_url = $this->fuzzyHrefMatch( $current_url, $type, $pos );
			if ( false !== $internal_url ) {
				$url->setAttribute( 'href', $internal_url );
				continue;
			}

			// Canonicalize, fix typos, remove garbage
			if ( isset( $current_url[0] ) && '#' !== $current_url[0] ) {
				$url->setAttribute( 'href', \Pressbooks\Sanitize\canonicalize_url( $current_url ) );
			}
		}

		return $doc;
	}


	/**
	 * Fuzzy image name match.
	 * For example: <a href="Some_Image-original.png"><img src="some_image-300x200.PNG" /></a>
	 * We consider both 'href' and 'src' above 'the same'
	 *
	 * @param string $file1
	 * @param string $file2
	 *
	 * @return bool
	 */
	protected function fuzzyImageNameMatch( $file1, $file2 ) {

		$file1 = basename( $file1 );
		$file2 = basename( $file2 );

		/* Compare extensions */

		$file1 = explode( '.', $file1 );
		$ext1 = strtolower( end( $file1 ) );

		$file2 = explode( '.', $file2 );
		$ext2 = strtolower( end( $file2 ) );

		if ( $ext1 !== $ext2 ) {
			return false;
		}

		/* Compare prefixes */

		$pre1 = explode( '-', $file1[0] );
		$pre1 = strtolower( $pre1[0] );

		$pre2 = explode( '-', $file2[0] );
		$pre2 = strtolower( $pre2[0] );

		if ( $pre1 !== $pre2 ) {
			return false;
		}

		return true;
	}


	/**
	 * Try to determine if a URL is pointing to internal content. TODO: Refactor, for the love of all that is holy.
	 *
	 * @param $url
	 * @param string $type front-matter, part, chapter, back-matter, ...
	 * @param int $pos (optional) position of content, used when creating filenames like: chapter-001, chapter-002, ...
	 *
	 * @return bool|string
	 */
	protected function fuzzyHrefMatch( $url, $type, $pos ) {
		if ( ! $pos ) {
			return false;
		}

		$url = trim( $url );
		$url = rtrim( $url, '/' );

		$domain = parse_url( $url );
		$domain = ( isset( $domain['host'] ) ) ? $domain['host'] : false;

		if ( $domain ) {
			$domain2 = parse_url( wp_guess_url() );
			$domain2 = ( isset( $domain2['host'] ) ) ? $domain2['host'] : false;
			if ( $domain2 !== $domain ) {
				return false; // If there is a domain name and it =/= ours, bail.
			}
		}

		$last_part = explode( '/', $url );
		$last_pos = count( $last_part ) - 1;
		$posttype = ( isset( $last_part[ $last_pos - 1 ] ) ) ? $last_part[ $last_pos - 1 ] : false;
		$anchor = '';

		// Look for #anchors
		if ( $last_pos > 0 && '#' === substr( trim( $last_part[ $last_pos ] ), 0, 1 ) ) {
			$anchor = trim( $last_part[ $last_pos ] );
			$last_part = trim( $last_part[ $last_pos - 1 ] );
		} elseif ( false !== strpos( $last_part[ $last_pos ], '#' ) ) {
			list( $last_part, $anchor ) = explode( '#', $last_part[ $last_pos ] );
			$anchor = trim( "#{$anchor}" );
			$last_part = trim( $last_part );
		} else {
			$last_part = trim( $last_part[ $last_pos ] );
		}

		if ( ! $last_part ) {
			return false;
		}

		$lookup = \Pressbooks\Book::getBookStructure();
		if ( 'part' !== $posttype && ! isset( $lookup['__export_lookup'][ $last_part ] ) ) {
			return false;
		}

		$new_url = '';
		if ( 'part' !== $posttype && isset( $lookup['__export_lookup'][ $last_part ] ) ) {
			// Handle front/back matter and chapters
			$new_type = $lookup['__export_lookup'][ $last_part ];
			$new_pos = 0;
			foreach ( $lookup['__export_lookup'] as $p => $t ) {
				if ( $t === $new_type ) {
					++$new_pos;
				}
				if ( $p === $last_part ) {
					break;
				}
			}
			$new_url = "$new_type-" . sprintf( '%03s', $new_pos ) . "-$last_part.{$this->filext}";
		} elseif ( 'part' === $posttype && ! isset( $lookup['__export_lookup'][ $last_part ] ) ) {
			// Handle parts
			foreach ( $lookup['part'] as $key => $part ) {
				if ( $part['post_name'] === $last_part ) {
					$new_url = 'part-' . sprintf( '%03s', $key + 1 ) . "-$last_part.{$this->filext}";
				}
			}
		}

		if ( $anchor ) {
			$new_url .= $anchor;
		}

		return $new_url;
	}


	/**
	 * Create OPF File.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @throws \Exception
	 */
	protected function createOPF( $book_contents, $metadata ) {

		if ( empty( $this->manifest ) ) {
			throw new \Exception( '$this->manifest cannot be empty. Did you forget to call $this->createOEPBS() ?' );
		}

		// Vars
		$vars = [
			'manifest' => $this->manifest,
			'stylesheet' => $this->stylesheet,
			'lang' => $this->lang,
		];

		$vars['manifest_assets'] = $this->buildManifestAssetsHtml();

		$vars['do_copyright_license'] = sanitize_xml_attribute(
			wp_strip_all_tags( $this->doCopyrightLicense( $metadata ), true )
		);

		// Sanitize metadata for usage in XML template
		foreach ( $metadata as $key => $val ) {
			$metadata[ $key ] = sanitize_xml_attribute( $val );
		}
		$vars['meta'] = $metadata;

		// Put contents
		file_put_contents(
			$this->tmpDir . '/book.opf',
			$this->loadTemplate( $this->dir . '/templates/epub201/opf.php', $vars )
		);
	}

	/**
	 * Find all the image files, insert them into the OPF file
	 *
	 * @return string
	 */
	protected function buildManifestAssetsHtml() {

		$html = '';
		$path_to_assets = $this->tmpDir . '/OEBPS/assets';
		$assets = scandir( $path_to_assets );
		$used_ids = [];

		foreach ( $assets as $asset ) {
			if ( '.' === $asset || '..' === $asset ) {
				continue;
			}
			$mimetype = $this->mediaType( "$path_to_assets/$asset" );
			if ( $this->coverImage === $asset ) {
				$file_id = 'cover-image';
			} else {
				$file_id = 'media-' . pathinfo( "$path_to_assets/$asset", PATHINFO_FILENAME );
				$file_id = Sanitize\sanitize_xml_id( $file_id );
			}

			// Check if a media id has already been used, if so give it a new one
			$check_if_used = $file_id;
			for ( $i = 2; $i <= 999; $i++ ) {
				if ( empty( $used_ids[ $check_if_used ] ) ) {
					break;
				} else {
					$check_if_used = $file_id . "-$i";
				}
			}
			$file_id = $check_if_used;

			$html .= sprintf( '<item id="%s" href="OEBPS/assets/%s" media-type="%s" />', $file_id, $asset, $mimetype ) . "\n";

			$used_ids[ $file_id ] = true;
		}

		return $html;
	}


	/**
	 * Create NCX file.
	 *
	 * @param array $book_contents
	 * @param array $metadata
	 *
	 * @throws \Exception
	 */
	protected function createNCX( $book_contents, $metadata ) {

		if ( empty( $this->manifest ) ) {
			throw new \Exception( '$this->manifest cannot be empty. Did you forget to call $this->createOEPBS() ?' );
		}

		// Sanitize variables for usage in XML template
		$vars = [
			'author' => isset( $metadata['pb_author'] ) ? sanitize_xml_attribute( $metadata['pb_author'] ) : '',
			'manifest' => $this->manifest,
			'dtd_uid' => ! empty( $metadata['pb_ebook_isbn'] ) ? sanitize_xml_attribute( $metadata['pb_ebook_isbn'] ) : sanitize_xml_attribute( get_bloginfo( 'url' ) ),
			'enable_external_identifier' => true,
			'lang' => $this->lang,
		];

		file_put_contents(
			$this->tmpDir . '/toc.ncx',
			$this->loadTemplate( $this->dir . '/templates/epub201/ncx.php', $vars )
		);
	}

	/**
	 * Dependency check.
	 *
	 * @return bool
	 */
	static function hasDependencies() {
		if ( false !== \Pressbooks\Utility\check_epubcheck_install() ) {
			return true;
		}

		return false;
	}

}
